// Class automatically generated by Dev-C++ New Class wizard

#ifndef MATRIX_H
#define MATRIX_H
#include <iostream>
#include <iomanip>
#include <cmath>
#include <string.h>
#include <cstdlib>
#include <stdio.h>

using namespace std;

/*
 * No description
 */
class matrix
{
	private:
		double mat[25][25];
		int ROW, COL;

		// for determinats
		double baseDet(matrix &A){
			return (A.get(0,0)*A.get(1,1) ) - ( A.get(1,0)*A.get(0,1));
		}
		void determ(matrix &m){
			double d = 1.0 / (m.get(0,0) * m.get(1,1) - m.get(1,0) * m.get(0,1)),
			       swp;

			// swap values in the uperleft and lower right
			swp = m.get(1,1);
			m.load(1, 1, (m.get(0,0)) );
			m.load(0, 0, swp);

			// multiply the remaning variables by -1
			m.load(0,1, (m.get(0,1) *-1));
			m.load(1,0, (m.get(1,0) *-1));

			m = m*d;
		}
		void findInv(matrix &m){
			double det;
			matrix Minor(m.getRow()-1, m.getCol()-1),
			       out(m.getRow(), m.getCol());

			det = 1.0/CalcDeterminat(m, m.getRow());

			for(int i=0; i<m.getRow(); i++){
				for(int u=0; u<m.getRow(); u++){
					getMinor(m, Minor, i, u, m.getRow());
					out.load(u,i, (det* CalcDeterminat(Minor, m.getRow()-1)));
					if((i+u)%2 ==1)
						out.load(u,i, -1.0*out.get(u,i));
				}
			}
			m = out;
		}
		int getMinor(matrix &src, matrix &dest, int row, int col, int order){
			int colCount=0,
			    rowCount=0;
			for(int i = 0; i < order; i++ ){
				if( i != row ){
					colCount =0;
					for(int j=0; j<order; j++){
						if(j != col){
							dest.load(rowCount,colCount, src.get(i,j));
							colCount++;
						}
					}
					rowCount++;
				}
			}
			return 1;
		}
		double CalcDeterminat(matrix &m, int order){
			if(order ==1)
				return m.get(0,0);
			double det =0;
			matrix Minor(order-1, order-1);

			for(int i=0; i<order; i++){
				getMinor(m, Minor, 0, i, order);
				det += ((i%2 == 1)?-1.0:1.0) * m.get(0,i) * CalcDeterminat(Minor, order-1);
			}
			return det;
		}
	public:
		// class constructor
		matrix(){
			ROW = COL = 4;
		}
		matrix(int r, int c){
			ROW = r;
			COL =c;
		}
		int getRow(){return ROW;}
		int getCol(){return COL;}
		void setCol(int lim){
			COL = lim;
		}
		////////////////////////////////////////////////////////////////////////
		// get individual elements from matrix
		double get(int r, int c){
			return mat[r][c];
		}
		// get row from matrix
		double *getRow(int r){
			return mat[r];
		}
		// get column from matrix
		double *getCol(int c){
			double *ret = new double[COL];

			for(int i=0; i<COL; i++)
				ret[i] = mat[i][c];

			return ret;
		}
		// load values into the matrix
		void load(int r, int c, double data){
			mat[r][c] = data;
		}
		// load a new row into the matrix
		void loadRow(double in[]){
			for(int i=0; i<COL; i++)
				mat[ROW][i] = in[i];
			ROW++;
		}
		// load a new colum into the matrix
		void loadCol(double in[]){
			for(int i=0; i<ROW; i++)
				mat[i][COL] = in[i];
			COL++;
		}
		void rmCol(int index){
			for(int r=0; r<ROW; r++)
				for(int c=index; c<COL; c++)
					if(index == (COL-1))
						load(r, c, 0);
					else
						swap(mat[r][c], mat[r][c+1]);
			COL--;
		}
		void rmRow(int index){
			for(int r=0; r<ROW; r++)
				for(int c=index; c<COL; c++)
					if(index == (ROW-1))
						load(r, c, 0);
					else
						swap(mat[r][c], mat[r+1][c]);
			ROW--;
		}
		void build(int c, int lim, float d[]){
			double tmp[lim];
			for(int i=0; i<lim; i++)
				tmp[i] = d[i];
			build(c,lim,tmp);
		}
		void build(int c, int lim, int d[]){
			double tmp[lim];
			for(int i=0; i<lim; i++)
				tmp[i] = d[i];
			build(c,lim,tmp);
		}
		void build(int c, int lim, double d[]){
			COL = c;
			ROW = 0;
			bool firstRow = true;

			for(int i=0; i<lim; i++){
				if(firstRow == false && (i%c)==0)
				{ROW++;}

				mat[ROW][i%c] = d[i];

				if(firstRow == true)
				{firstRow = (i == (c-1))?false:true;}
			}
			ROW++;
		}
		void build(){
			string input;
			double intoMat;

			for(int i=0; i<ROW; i++)
				for(int u=0; u<COL; u++){
					cout << "      >> ";
					cin >> input;
					intoMat = strtod(input.data(),NULL);
					load(i, u, intoMat);
				}
		}
		friend matrix pow(matrix m, int index){
			matrix tmp = m;

			if(m.COL != m.ROW)
				return m;
			// if index is 0 then load identity into incoming matrix
			if(index == 0){
				for(int r=0; r<m.ROW; r++)
					for(int c=0; c<m.COL; c++)
						m.load(r, c, ((r==c)?1:0));
				return m;
			}
			// for negative numbers invers the matrix then proseeed as usual
			if(index < 0){
				tmp = m.invert();
				m = tmp;
				index *= -1;
			}

			for(int i=1; i<index; i++)
				m = m * tmp;

			return m;
		}
		friend matrix flip(matrix &m){
			return m.tran();
		}
		void flip(){
			*this = tran();
		}
		matrix aug(matrix B){
			if(ROW != B.getRow())
				return *this;
			COL += B.getCol();
			for(int r=0; r<B.getRow(); r++)
				for(int c=0; c<B.getCol(); c++)
					load(r, c+ROW, B.get(r,c));
			return *this;
		}
		///////////////////////////////////////////////////
		matrix invert(){
			matrix temp(ROW,COL);

			if(COL==2 and ROW==2){
				for(int i=0; i<2; i++){
					for(int u=0; u<2; u++)
						temp.load(i, u, mat[i][u]);
				}
				determ(temp);
			}else{
				for(int i=0; i<ROW; i++){
					for(int u=0; u<COL; u++)
						temp.load(i, u, mat[i][u]);
				}
				findInv(temp);
			}
			return temp;
		}
		matrix ref(){
			double *ra, *rb;
			double mul, gh;
			int np;
			matrix temp(ROW,COL);

			// coppy the currnet matrix into temp matrix
			for(int r=0; r<ROW; r++)
				for(int c=0; c<COL; c++)
					temp.load(r, c, mat[r][c]);

			for(int r=0, pivot=0; r<ROW; r++){
				// calculate ref
				// swap rows that contain 0 at pivit points with one that does not
				if(temp.get(r,pivot) ==0)	
					for(int i=(r+1); i<ROW; i++){
						if(temp.get(i,pivot) !=0){
							temp.swapRow(r, (i%ROW));
							//if(temp.get(i,pivot) !=0){
							break;
						}
						}
						// find new pifit point if nesisary
						if(temp.get(r,pivot) ==0)
							for(int i=0; i<COL; i++){
								//if(temp.get(r,i)==1 and temp.get(r,(i-1))==0 and i>0){
								if((temp.get(r,i) >0 or temp.get(r,i)<0) and temp.get(r,(i-1)) ==0){
									pivot = i;
									break;
								}
							}

							// convert pivit point to 1 if its grater than 1
							if(temp.get(r,pivot) > 0 and temp.get(r,pivot) != 0){
								mul = 1/temp.get(r,pivot);
								for(int i=0; i<COL; i++)
									temp.load(r,i, mul * temp.get(r,i));
							}
							// convert pivot point to 1 if its less than 1
							if(temp.get(r,pivot) <0 and(temp.get(r,pivot)!=0 or temp.get(r,pivot)!=1)){
								mul = -1/temp.get(r,pivot);
								for(int i=0; i<COL; i++)
									temp.load(r,i, mul * temp.get(r,i));
							}
							// correct the piviot point if its negative
							if(temp.get(r,pivot) < 0){
								for(int i=0; i<COL; i++)
									if(temp.get(r, i) !=0)
										temp.load(r,i, -1 * temp.get(r,i));
							}

							ra = temp.getRow(r);// get current row with pivot point
							// calculate ref
							for(int r2= (r+1); r2<ROW; r2++){
								rb = temp.getRow(r2);

								if(rb[pivot] > 0 or rb[pivot] < 0){
									mul = rb[pivot];
									mul *= -1;

									for(int c=0; c<COL; c++){
										gh = (mul *ra[c]) + rb[c];
										gh = (gh<=1.0e-8 and gh >-1e-8)?0:gh;
										gh = (gh >= .99999 and gh <=1.0000009)?1:gh;
										temp.load(r2, c, gh);
									}
								}
							}
							pivot++;
							}
						return temp;

					}
				matrix rref(){
					matrix tmp(ROW, COL);
					double *ra, *rb;
					double mul, gh;

					// coppy the currnet matrix into temp matrix
					for(int r=0; r<ROW; r++)
						for(int c=0; c<COL; c++)
							tmp.load(r, c, mat[r][c]);

					// get ref of the matrix
					tmp = tmp.ref();

					// calculate rref
					for(int r=(ROW-1), pivot=0; r>=0; r--){
						ra = tmp.getRow(r);

						// get the pivot point
						for(int i=0; i<COL; i++){
							ra[i] = (ra[i] <= 1e-8 and ra[i] >-1e-8)?0:ra[i];
							ra[i+1] = (ra[i+1] >= .99999 and ra[i+1] <=1.0000009)?1:ra[i+1];
							if(ra[i]==0 and ra[i+1]==1){
								pivot = i+1;
								break;
							}
						}

						// calculate rref
						for(int r2=(r-1); r2>=0; r2--){
							rb = tmp.getRow(r2); // get the row above the pivot point
							if(rb[pivot] > 0 or rb[pivot] <0){
								mul = rb[pivot];
								mul *= -1;
								for(int bt=0; bt <COL; bt++){
									gh = (mul * ra[bt]) + rb[bt];
									tmp.load(r2, bt, gh);
								}
							}
						}
					}

					return tmp;
				}
				void swapRow(int r1, int r2){
					double *n1, *n2;

					n1 = getRow(r1);
					n2 = getRow(r2);

					// swap componets
					for(int i=0; i<COL; i++)
						swap(n1[i], n2[i]);

					// load swaped rows
					for(int i=0; i<COL; i++){
						load(r1,i, n1[i]);
						load(r2,i, n2[i]);
					}
				}
				void swapCol(int r1, int r2){
					double *n1, *n2;

					n1 = getCol(r1);
					n2 = getCol(r2);

					// swap componets
					for(int i=0; i<ROW; i++)
						swap(n1[i], n2[i]);

					// load swaped rows
					for(int i=0; i<ROW; i++){
						load(i,r1, n1[i]);
						load(i,r2, n2[i]);
					}
					delete [] n1;
					delete [] n2;
				}
				double det(){
					return CalcDet(*this);
				}
				double CalcDet(matrix A){
					double larr[ROW*COL];
					double mult, ret=0, out=0;

					if(A.getRow() == A.getCol()){
						matrix temp(A.getRow()-1, A.getCol()-1);

						if(A.getRow() == 2){
							return baseDet(A);
						}
						for(int c=0; c<A.getCol(); c++){
							mult = A.get(0,c);
							//if(mult == 0) {cout << mult << endl;return 0;}
							mult *= ((c%2) != 0 and mult !=0)?-1:1;

							// get sub matrix value
							for(int r=1, x=0; r<A.getCol(); r++)
								for(int i=0; i<A.getCol(); i++)
									if(i != c) larr[x++] = A.get(r,i);
							// load sub matrix
							for(int r=0, x=0; r<temp.getRow(); r++)
								for(int i=0; i<temp.getCol(); i++)
									temp.load(r, i, larr[x++]);
							ret += mult * CalcDet(temp);
							out += ret;
						}
						return ret;
					}else{
						return 0;
					}
				}
				matrix cof(matrix B){
					matrix tmp, augm(ROW,1);
					double intoMat, baseDet;
					tmp = *this;


					baseDet = CalcDet(tmp);

					for(int u=0; u<getCol(); u++){
						// load raw determinat matrix
						for(int r=0; r<getRow(); r++)
							for(int c=0; c<getCol(); c++){
								if(c == u)
									tmp.load(r, c,  B.get(r,0));
								else
									tmp.load(r, c, get(r,c));
							}

						// calculate cofacror
						intoMat = CalcDet(tmp);
						intoMat = intoMat / baseDet;

						// load the results into cofactor matrix
						augm.load(u, 0, intoMat);
					}
					return augm;
				}
				matrix col(){
					int i=0;
					int index[getCol()];
					matrix tmp = *this;

					tmp = tmp.rref();
					for(int r=0; r<ROW; r++)
						for(int c=0; c<COL; c++)
							if((((c-1)>=0 and c<getCol()) or c==0))
								if((int(tmp.get(r,(c-1))) == 0 or c==0 )and tmp.get(r,c) ==1){
									index[i++] = c;
								}
					// make new matrix
					matrix newCOL(getRow(), i);
					for(int r=0; r<tmp.getRow(); r++)
						for(int u=0; u< i; u++)
							newCOL.load(r,u, get(r,index[u]));
					return newCOL;

				}
				matrix cof(){
					double coel;
					matrix out= *this,
					       tmin(ROW-1,COL-1);

					if(ROW == COL){
						for(int mr=0, i=0; mr<ROW; mr++)
							for(int mc=0; mc<COL; mc++){
								for(int r=0,xr=0; r<ROW; r++)
									for(int c=0, xc=0; c<COL; c++)
										if(r!=mr and c!=mc){
											tmin.load(xr, xc++, get(r,c) );
											xr+=(xc==tmin.getCol()&& xc>0)?1:0;
										}
								coel = CalcDet(tmin) * pow(-1.0, (i++));
								out.load(mr, mc, coel);
							}
						return out;
					}
					return *this;
				}
				matrix tran(){
					matrix trp(COL,ROW);

					for(int r=0; r<ROW; r++)
						for(int c=0; c<COL; c++)
							trp.load(c,r,get(r,c));
					return trp;
				}
				matrix null(){
					matrix lock, free;
					int index[COL],
					    frenx[COL];
					int i=0, x=0;
					double *vec;
					double push;

					free = rref();
					lock = col();  // get the size of the column space
					if(lock.getCol() == COL){
						matrix Zero(COL,1);
						return Zero;
					}

					// //////////////////////////////////////////////////////////////////////////////////
					for(int r=0; r<free.getRow(); r++)
						for(int c=0; c<free.getCol(); c++)
							if((((c-1)>=0 and c<free.getCol()) or c==0))
								if((free.get(r,(c-1)) == 0 or c==0 )and free.get(r,c) ==1)
									index[i++] = c;

					i=0;
					for(int w=0; w< free.getCol(); w++)
						if(w != index[i]){
							frenx[x++] = w;
						}else i++;

					matrix tmp(ROW, (COL-i));
					for(int r=0; r<free.getRow(); r++)
						for(int u=0; u< x; u++)
							tmp.load(r,u, free.get(r,frenx[u]));
					free = tmp;
					lock = lock.rref();

					// calc NULL vectors //////////////////////////////////////////////////
					matrix ret(COL, free.getCol());
					for(int c=0; c<ret.getRow(); c++)
						for(int r=0; r<ret.getCol(); r++)
							ret.load(r, c, 0);

					vec = free.getCol(0);
					lock.loadCol(vec);
					delete [] vec;
					for(int c=0; c<lock.getRow(); c++)
						lock.load(c, (lock.getCol()-1), free.get(c,0));

					// get multipliers for lock verticies
					for(int r=0; r<ret.getCol(); r++){
						for(int c=0; c<lock.getCol(); c++){
							if(c == (lock.getCol()-1)or lock.get(c,c) ==0) 
								break;
							push = (-1* lock.get(c, (lock.getCol()-1))) / lock.get(c,c);
							push = (push == -0)?0:push;
							push = (push<=1.0e-8 and push >-1e-8)?0:push;
							ret.load(index[c],r, push);
						}
						for(int c=0; c<lock.getRow(); c++)
							lock.load(c, (lock.getCol()-1), free.get(c,r+1));
					}
					// include nessisary 1's
					for(int r=0; r<ret.getRow(); r++)
						for(int c=0; c<ret.getCol(); c++)
							if(r == frenx[c]){
								ret.load(r, c, 1);
								break;
							}

					return ret;
				}
				double length(double *col, int sz){
					double raw=0;
					for(int i=0; i<sz; i++)
						raw += col[i] * col[i];
					return sqrt(raw);
				}
				// cout overloading ///////////////////////////////////////////////////
				friend ostream& operator <<(ostream &out, matrix B){
					char *tmp;
					int buf =0;

					// get the size of eatch length of eatch number to get a squar matrix
					for(int i=0; i<B.getRow(); i++){
						for(int u=0; u<B.getCol(); u++){
							sprintf((tmp = new char), "%g", ((B.get(i,u)>=-1e-10 and B.get(i,u)<=1e-10)?0:B.get(i, u)));
							if(buf < strlen(tmp))
								buf = strlen(tmp);
							delete [] tmp;
						}
					}

					for(int i=0; i<B.getRow(); i++){
						for(int u=0; u<B.getCol(); u++)
							out << setw(buf+2) << ((B.get(i,u)>=-1e-10 and B.get(i,u)<=1e-10)?0:B.get(i,u)) << ", ";
						out << endl;
					}
					return out;
				}
				////////////////////////////////////////////////////////////////////////
				friend matrix operator +(matrix A, const double num){
					matrix temp(A.ROW, A.COL);

					temp = num + A;
					return temp;
				}
				friend matrix operator +(const double num, matrix A){
					matrix temp(A.ROW, A.COL);
					for(int i=0; i<A.ROW; i++)
						for(int u=0; u< A.COL; u++)
							temp.load(i, u, (u == i)?1:0);

					temp = num * temp;
					temp = temp + A;
					return temp;
				}
				friend matrix operator +(matrix A, matrix B){
					matrix temp(A.ROW,A.COL);

					for(int i=0; i<A.ROW; i++){
						for(int u=0; u< A.COL; u++){
							temp.load(i, u, (B.get(i,u) + A.mat[i][u]) );
						}
					}
					return temp;
				}
				friend matrix operator -(matrix A, const double num){
					matrix temp(A.ROW,A.COL);

					temp = (-1* num) + A;
					return temp;
				}
				friend matrix operator -(const double num, matrix A){
					matrix temp(A.ROW,A.COL);
					for(int i=0; i<A.ROW; i++)
						for(int u=0; u< A.COL; u++)
							temp.load(i, u, (u == i)?1:0);

					temp = num * temp;
					temp = temp - A;
					return temp;
				}
				friend matrix operator -(matrix A, matrix B){
					matrix temp(A.ROW,A.COL);

					for(int i=0; i<A.ROW; i++){
						for(int u=0; u< A.COL; u++){
							temp.load(i, u, (A.mat[i][u]) - B.get(i,u));
						}
					}
					return temp;
				}
				friend matrix operator *(matrix A, matrix B){
					matrix temp(A.getRow(), B.getCol());
					double doted = 0;

					// asign temp  values to zero
					for(int i=0; i<temp.getRow(); i++)
						for(int u=0; u<temp.getCol(); u++)
							temp.load(i, u, 0);

					cout << "temp =(" << temp.getRow() <<"x" << temp.getCol() << ")"<<endl;
					// do multiplication
					for(int ar=0; ar<A.getRow(); ar++){
						for(int bc=0; bc<B.getCol(); bc++){
							for(int rCalc=0; rCalc<A.getCol(); rCalc++)
								doted +=(A.get(ar, rCalc) * B.get(rCalc, bc));
							temp.load(ar, bc,   doted );
							doted = 0;
						}
					}
					return temp;
				}
				friend matrix operator *(const double num, matrix A){
					matrix temp(A.getRow(), A.getCol());
					temp = A*num;
					return temp;
				}
				friend matrix operator *(matrix A, const double num){
					matrix temp(A.ROW, A.COL);
					double mul;
					for(int y=0; y<A.ROW; y++)
						for(int x=0; x<A.COL; x++){
							mul = A.mat[y][x] * num;
							temp.load(y, x, mul);
						}
					return temp;
				}
				////////////////////////////////////////////////////////////////////////
				matrix &operator =(matrix B){
					if(B.getRow() != ROW || B.getCol() != COL){
						COL = B.getCol();
						ROW = B.getRow();
					}
					for(int i=0; i<B.getRow(); i++){
						for(int u=0; u<B.getCol(); u++){
							mat[i][u] = B.get(i,u);}
					}
					return *this;

				}
				// class destructor
				~matrix(){
				}
			};

#endif // MATRIX_H
