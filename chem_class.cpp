// Class automatically generated by Dev-C++ New Class wizard

#include "chem.h" // class's header file
#include "Resor.h" // Resorces header file
#include "chemForm.h" // get Chemical Variable
#include "vipLl.h" 
#include "matrix.h" 
#include <iostream>
#include <iomanip>
#include <string>
#include <cmath>
#include <cstdlib>
#include <cstdlib>

using namespace std;

resor resu; // RESORCES OBJECT
struct compound{
	string name;
	string *elm;
	int *ecount;
	int count;
	int mult;
};

struct periodicTable
{
	string name;
	double w;
}pt[119];
struct bolingFrezing
{
	string name;
	double kb;
	double kf;
}k[30];
struct Ions
{
	string ionName;
	string metalName;
	int ionCharge;
	int metalCharge;
}ions[65];

string knownIon[60];

double const pi = 3.141592653589793238462643383279502884197169399375105820974944;
// class constructor

chem::chem()
{
	// insert your code here

	pt[0].name = "H" ;   pt[0].w = 1.008 ;
	pt[1].name = "He";   pt[1].w = 4.003 ;
	pt[2].name = "li";   pt[2].w = 6.941 ;
	pt[3].name = "Be";   pt[3].w = 9.012 ;
	pt[4].name = "B" ;   pt[4].w = 10.81 ;
	pt[5].name = "C";    pt[5].w = 12.01 ;
	pt[6].name = "N";    pt[6].w = 14.01 ;
	pt[7].name = "O";    pt[7].w = 16 ;
	pt[8].name = "F" ;   pt[8].w = 19 ;
	pt[9].name = "Ne";   pt[9].w = 20.18 ;

	pt[10].name = "Na";  pt[10].w = 22.99 ;
	pt[11].name = "Mg";  pt[11].w = 24.31;
	pt[12].name = "Al" ; pt[12].w = 26.98 ;
	pt[13].name = "Si";  pt[13].w = 28.09;
	pt[14].name = "P";   pt[14].w = 30.97;
	pt[15].name = "S";   pt[15].w = 32.07;
	pt[16].name = "Cl" ; pt[16].w = 35.05 ;
	pt[17].name = "Ar";  pt[17].w = 39.95;
	pt[18].name = "K";   pt[18].w = 39.10;
	pt[19].name = "Ca";  pt[19].w = 40.08 ;

	pt[20].name = "Sc" ; pt[20].w = 44.96 ;
	pt[21].name = "Ti";  pt[21].w = 47.88 ;
	pt[22].name = "V";   pt[22].w =  50.94;
	pt[23].name = "Cr";  pt[23].w = 52 ;
	pt[24].name = "Mn";  pt[24].w = 54.94;
	pt[25].name = "Fe";  pt[25].w = 55.85 ;
	pt[26].name = "Co" ; pt[26].w = 58.93 ;
	pt[27].name = "Ni";  pt[27].w = 58.69;
	pt[28].name = "Cu";  pt[28].w =  63.55;
	pt[29].name = "Zn";  pt[29].w = 65.38;

	pt[30].name = "Ga";  pt[30].w = 69.72;
	pt[31].name = "Ge" ; pt[31].w = 72.59;
	pt[32].name = "As";  pt[32].w = 74.92;
	pt[33].name = "Se";  pt[33].w = 78.96;
	pt[34].name = "Br";  pt[34].w = 79.90;
	pt[35].name = "Kr";  pt[35].w = 83.80;
	pt[36].name = "Rb";  pt[36].w = 85.47;
	pt[37].name = "Sr" ; pt[37].w = 87.62;
	pt[38].name = "Y";   pt[38].w = 88.91;
	pt[39].name = "Zr";  pt[39].w = 91.22;

	pt[40].name = "Nb";  pt[40].w = 92.91;
	pt[41].name = "Mo" ; pt[41].w = 95.94;
	pt[42].name = "Te";  pt[42].w = 98;
	pt[43].name = "Ru";  pt[43].w = 101.1;
	pt[44].name = "Rh";  pt[44].w = 102.9;
	pt[45].name = "Pd";  pt[45].w = 106.4;
	pt[46].name = "Ag";  pt[46].w = 107.9;
	pt[47].name = "Cd" ; pt[47].w = 112.4;
	pt[48].name = "In";  pt[48].w = 114.8;
	pt[49].name = "Sn";  pt[49].w = 118.7;

	pt[50].name = "Sb";  pt[50].w = 121.8;
	pt[51].name = "Te" ; pt[51].w = 127.6;
	pt[52].name = "I";   pt[52].w = 126.9;
	pt[53].name = "Xe";  pt[53].w = 131.3;
	pt[54].name = "Cs";  pt[54].w = 132.9;
	pt[55].name = "Ba";  pt[55].w = 137.3;
	pt[56].name = "La";  pt[56].w = 138.9;
	pt[57].name = "Ce" ; pt[57].w = 140.1;
	pt[58].name = "Pr";  pt[58].w = 140.9;
	pt[59].name = "Nd";  pt[59].w = 144.2;

	pt[60].name = "Pm";  pt[60].w = 145;
	pt[61].name = "Sm" ; pt[61].w = 150.4;
	pt[62].name = "Eu";  pt[62].w = 152.0;
	pt[63].name = "Gd";  pt[63].w = 157.3;
	pt[64].name = "Tb";  pt[64].w = 158.9;
	pt[65].name = "Dy";  pt[65].w = 162.9;
	pt[66].name = "Ho";  pt[66].w = 164.9;
	pt[67].name = "Er" ; pt[67].w = 167.3;
	pt[68].name = "Tm";  pt[68].w = 168.9;
	pt[69].name = "Yb";  pt[69].w = 173.0;

	pt[70].name = "Lu";  pt[70].w = 175.0;
	pt[71].name = "Hf" ; pt[71].w = 178.5;
	pt[72].name = "Ta";  pt[72].w = 180.9;
	pt[73].name = "W";   pt[73].w = 183.9;
	pt[74].name = "Re";  pt[74].w = 186.2;
	pt[75].name = "Os";  pt[75].w = 190.2;
	pt[76].name = "Ir";  pt[76].w = 192.2;
	pt[77].name = "Pt" ; pt[77].w = 195.1;
	pt[78].name = "Au";  pt[78].w = 197.0;
	pt[79].name = "Hg";  pt[79].w = 200.6;

	pt[80].name = "Tl";  pt[80].w = 204.4;
	pt[81].name = "Pb" ; pt[81].w = 207.2;
	pt[82].name = "Bi";  pt[82].w = 209.0;
	pt[83].name = "Po";  pt[83].w = 209;
	pt[84].name = "At";  pt[84].w = 210;
	pt[85].name = "Rn";  pt[85].w = 222;
	pt[86].name = "Fr";  pt[86].w = 223;
	pt[87].name = "Ra" ; pt[87].w = 226;
	pt[88].name = "Ac";  pt[88].w = 227;
	pt[89].name = "Th";  pt[89].w = 232.0;

	pt[90].name = "Pa";  pt[99].w = 231;
	pt[91].name = "U" ;  pt[91].w = 238.0;
	pt[92].name = "Np";  pt[92].w = 237;
	pt[93].name = "Pu";  pt[93].w = 244;
	pt[94].name = "Am";  pt[94].w = 243;
	pt[95].name = "Cm";  pt[95].w = 247;
	pt[96].name = "Bk";  pt[96].w = 247;
	pt[97].name = "Cf" ; pt[97].w = 251;
	pt[98].name = "Es";  pt[98].w = 252;
	pt[99].name = "Fm";  pt[99].w = 257;

	pt[100].name = "Md";  pt[100].w = 258;
	pt[101].name = "No" ; pt[101].w = 259;
	pt[102].name = "Lr";  pt[102].w = 260;
	pt[103].name = "Rf";  pt[103].w = 261;
	pt[104].name = "Db";  pt[104].w = 262;
	pt[105].name = "Sg";  pt[105].w = 263;
	pt[106].name = "Bh";  pt[106].w = 264;
	pt[107].name = "Hs" ; pt[107].w = 265;
	pt[108].name = "Mt";  pt[108].w = 268;
	pt[109].name = "Ds";  pt[109].w = 271;

	pt[110].name = "Rg";  pt[110].w = 272;
	pt[111].name = "Cn" ; pt[111].w = 285;
	pt[112].name = "Uut";  pt[112].w = 286;
	pt[113].name = "Fl";  pt[113].w = 289;
	pt[114].name = "Uup";  pt[114].w = 288;
	pt[115].name = "Lv";  pt[115].w = 293;
	pt[116].name = "Uus";  pt[116].w = 294;
	pt[117].name = "Uuo" ; pt[117].w = 294;
	pt[118].name = "Uud";  pt[118].w = 295;

	k[0].name = "water";               k[0].kb = 0.51; k[0].kf = 1.86;
	k[1].name = "carbonTetrachloride"; k[1].kb = 5.03; k[1].kf = 30.0;
	k[2].name = "chloroform";          k[2].kb = 3.63; k[2].kf = 4.70;
	k[3].name = "benzene";             k[3].kb = 2.53; k[3].kf = 5.12;
	k[4].name = "corbonDisulfide";     k[4].kb = 2.34; k[4].kf = 3.83;
	k[5].name = "ethylEther";          k[5].kb = 2.02; k[5].kf = 1.79;
	k[6].name = "camphor";             k[6].kb = 5.95; k[6].kf = 40;

	ions[0].ionName = "Li"; ions[0].metalName = "Li"; ions[0].ionCharge = 1; ions[0].metalCharge = 1;
	ions[1].ionName = "Na"; ions[1].metalName = "Na"; ions[1].ionCharge = 1; ions[1].metalCharge = 1;
	ions[2].ionName = "K";  ions[2].metalName = "K";  ions[2].ionCharge = 1; ions[2].metalCharge = 1;
	ions[3].ionName = "Rb"; ions[3].metalName = "Rb"; ions[3].ionCharge = 1; ions[3].metalCharge = 1;
	ions[4].ionName = "Cs"; ions[4].metalName = "Cs"; ions[4].ionCharge = 1; ions[4].metalCharge = 1;
	ions[5].ionName = "Fr"; ions[5].metalName = "Fr"; ions[5].ionCharge = 1; ions[5].metalCharge = 1;
	ions[6].ionName = "Be"; ions[6].metalName = "Be"; ions[6].ionCharge = 2; ions[6].metalCharge = 2;
	ions[7].ionName = "Mg"; ions[7].metalName = "Mg"; ions[7].ionCharge = 2; ions[7].metalCharge = 2;
	ions[8].ionName = "Ca"; ions[8].metalName = "Ca"; ions[8].ionCharge = 2; ions[8].metalCharge = 2;
	ions[9].ionName = "Sr"; ions[9].metalName = "Sr"; ions[9].ionCharge = 2; ions[9].metalCharge = 2;

	ions[10].ionName = "Ba"; ions[10].metalName = "Ba"; ions[10].ionCharge = 2; ions[10].metalCharge = 2;
	ions[11].ionName = "Ra"; ions[11].metalName = "Ra"; ions[11].ionCharge = 2; ions[11].metalCharge = 2;
	ions[12].ionName = "B";  ions[12].metalName = "B";  ions[12].ionCharge = 3; ions[12].metalCharge = 3;
	ions[13].ionName = "Al"; ions[13].metalName = "Al"; ions[13].ionCharge = 3; ions[13].metalCharge = 3;
	ions[14].ionName = "Ga"; ions[14].metalName = "Ga"; ions[14].ionCharge = 3; ions[14].metalCharge = 3;
	ions[15].ionName = "Ln"; ions[15].metalName = "Ln"; ions[15].ionCharge = 3; ions[15].metalCharge = 3;
	ions[16].ionName = "Ti"; ions[16].metalName = "Ti"; ions[16].ionCharge = 3; ions[16].metalCharge = 3;
	ions[17].ionName = "Uut";ions[17].metalName = "Uut";ions[17].ionCharge = 3; ions[17].metalCharge = 3;
	ions[18].ionName = "Ag"; ions[18].metalName = "Ag"; ions[18].ionCharge = 1; ions[18].metalCharge = 1;
	ions[19].ionName = "Zn"; ions[19].metalName = "Zn"; ions[19].ionCharge = 2; ions[19].metalCharge = 2;

	ions[20].ionName = "NH4"; ions[20].metalName = ""; ions[20].ionCharge = 1;  ions[20].metalCharge = 1;
	ions[21].ionName = "ClO4";ions[21].metalName = ""; ions[21].ionCharge = -1; ions[21].metalCharge = -1;
	ions[22].ionName = "ClO3";ions[22].metalName = ""; ions[22].ionCharge = -1; ions[22].metalCharge = -1;
	ions[23].ionName = "C2H3O2"; ions[23].metalName = ""; ions[23].ionCharge = -1; ions[23].metalCharge = -1;
	ions[24].ionName = "SO4"; ions[24].metalName = ""; ions[24].ionCharge = -2; ions[24].metalCharge = -2;
	ions[25].ionName = "CO3"; ions[25].metalName = ""; ions[25].ionCharge = -2; ions[25].metalCharge = -2;
	ions[26].ionName = "PO4"; ions[26].metalName = ""; ions[26].ionCharge = -3; ions[26].metalCharge = -3;
	ions[27].ionName = "CrO4";ions[27].metalName = ""; ions[27].ionCharge = -2; ions[27].metalCharge = -2;
	ions[28].ionName = "AsO4";ions[28].metalName = ""; ions[28].ionCharge = -3; ions[28].metalCharge = -3;
	ions[29].ionName = "OH";  ions[29].metalName = ""; ions[29].ionCharge = -1; ions[29].metalCharge = -1;

	ions[30].ionName = "NO3"; ions[30].metalName = ""; ions[30].ionCharge = -1; ions[30].metalCharge = -1;
	ions[31].ionName = "C2O4";ions[31].metalName = ""; ions[31].ionCharge = -2; ions[31].metalCharge = -2;
	ions[32].ionName = "SO3"; ions[32].metalName = ""; ions[32].ionCharge = -2; ions[32].metalCharge = -2;
	ions[33].ionName = "PO4"; ions[33].metalName = ""; ions[33].ionCharge = -3; ions[33].metalCharge = -3;
	ions[34].ionName = "ClO2";ions[34].metalName = ""; ions[34].ionCharge = -1; ions[34].metalCharge = -1;
	ions[35].ionName = "ClO"; ions[35].metalName = ""; ions[35].ionCharge = -1; ions[35].metalCharge = -1;
	ions[36].ionName = "CN";  ions[36].metalName = ""; ions[36].ionCharge = -1; ions[36].metalCharge = -1;
	ions[37].ionName = "NO2"; ions[37].metalName = ""; ions[37].ionCharge = -1; ions[37].metalCharge = -1;
	ions[38].ionName = "Cr2O7"; ions[38].metalName = ""; ions[38].ionCharge = -2; ions[38].metalCharge = -2;
	ions[39].ionName = "CrO4"; ions[39].metalName = ""; ions[39].ionCharge = -2; ions[39].metalCharge = -2;

	ions[40].ionName = "MnO4"; ions[40].metalName = "";ions[40].ionCharge = -1;ions[40].metalCharge = -1;
	ions[41].ionName = "NCS";ions[41].metalName = ""; ions[41].ionCharge = -1; ions[41].metalCharge = -1;
	/**/    ions[42].ionName = "H"; ions[42].metalName = ""; ions[42].ionCharge = 1;  ions[42].metalCharge = 1;
	ions[43].ionName = "F"; ions[43].metalName = ""; ions[43].ionCharge = -1; ions[43].metalCharge = -1;
	ions[44].ionName = "Cl"; ions[44].metalName = ""; ions[44].ionCharge = -1; ions[44].metalCharge = -1;
	ions[45].ionName = "Br"; ions[45].metalName = ""; ions[45].ionCharge = -1; ions[45].metalCharge = -1;
	ions[46].ionName = "I";  ions[46].metalName = ""; ions[46].ionCharge = -1; ions[46].metalCharge = -1;
	ions[47].ionName = "At"; ions[47].metalName = ""; ions[47].ionCharge = -1; ions[47].metalCharge = -1;
	ions[48].ionName = "Uus";ions[48].metalName = ""; ions[48].ionCharge = -1; ions[48].metalCharge = -1;
	ions[49].ionName = "O";  ions[49].metalName = ""; ions[49].ionCharge = -2; ions[49].metalCharge = -2;

	ions[50].ionName = "S";ions[50].metalName = ""; ions[50].ionCharge = -2; ions[50].metalCharge = -2;
	ions[51].ionName = "Se";ions[51].metalName = ""; ions[51].ionCharge = -2; ions[51].metalCharge = -2;
	ions[52].ionName = "Te";ions[52].metalName = ""; ions[52].ionCharge = -2; ions[52].metalCharge = -2;
	ions[53].ionName = "Po";ions[53].metalName = ""; ions[53].ionCharge = -2; ions[53].metalCharge = -2;
	ions[54].ionName = "Lv";ions[54].metalName = ""; ions[54].ionCharge = -2; ions[54].metalCharge = -2;
	ions[55].ionName = "N";ions[55].metalName = ""; ions[55].ionCharge = -3; ions[55].metalCharge = -3;
	ions[56].ionName = "P";ions[56].metalName = ""; ions[56].ionCharge = -3; ions[56].metalCharge = -3;
	ions[57].ionName = "As";ions[57].metalName = ""; ions[57].ionCharge = -3; ions[57].metalCharge = -3;
	ions[58].ionName = "Sb";ions[58].metalName = ""; ions[58].ionCharge = -3; ions[58].metalCharge = -3;
	ions[59].ionName = "Bi";ions[59].metalName = ""; ions[59].ionCharge = -3; ions[59].metalCharge = -3;

	ions[60].ionName = "Uup";ions[60].metalName = ""; ions[60].ionCharge = -3; ions[60].metalCharge = -3;

	knownIon[0] = "MnO4"; knownIon[1] = "O4Mn"; knownIon[2] = "NCS"; knownIon[3] = "NSC"; knownIon[4]="CNS";
	knownIon[5] = "CSN"; knownIon[6] = "SNC"; knownIon[7] = "SCN"; knownIon[8] = "ClO2"; knownIon[9]="O2Cl";
	knownIon[10] = "ClO"; knownIon[11] = "OCl"; knownIon[12] = "NC"; knownIon[13] = "CN"; knownIon[14]="NO2";
	knownIon[15] = "O2N"; knownIon[16] = "Cr2O7"; knownIon[17] = "O7Cr2"; knownIon[18] = "CrO4"; knownIon[19]="O4Cr";
	knownIon[20] = "PO4"; knownIon[21] = "O4P"; knownIon[22] = "SO3"; knownIon[23] = "O3S"; knownIon[24]="C2O4";
	knownIon[25] = "O4C2"; knownIon[26] = "O4Mn"; knownIon[27] = "NO3"; knownIon[28] = "O3N"; knownIon[29]="OH";

	knownIon[30] = "AsO4"; knownIon[31] = "O4As"; knownIon[32] = "CrO4"; knownIon[33] = "O4Cr"; knownIon[34]="PO4";
	knownIon[35] = "O4P"; knownIon[36] = "CO3"; knownIon[37] = "O3C"; knownIon[38] = "SO4"; knownIon[39]="O4S";

	knownIon[40] = "C2H3O2"; knownIon[41] = "C2O2H3"; knownIon[42] = "H3C2O2"; knownIon[43] = "H3O2C2"; knownIon[44]="O2H3C2";
	knownIon[45] = "O2C2H3"; knownIon[46] = "ClO3"; knownIon[47] = "ClO4"; knownIon[48] = "O4Cl"; knownIon[49]="O3Cl";
	knownIon[50] = "NH4"; knownIon[51] = "H4N", knownIon[52] = "CN", knownIon[53] = "NC"; 

}
//============================================================================================
void chem::charlaw()
{
	string sel, raw;     
	double kel1, kel2, vol1, vol2, ans;
	while(true){
		cout << "\nViper_Chem_CharlLaw: ";
		cin >> sel;
		resu.IN_History(sel);
		resu.univSelec(sel,sel);

		if(sel =="vol" ||sel =="Vol" ||sel =="VOL")
		{
			cout << "Enter inical temp in kelven: ";
			kel1 = resu.VDO();
			cout << "Enter inical volume of gass: ";
			vol1 = resu.VDO();
			cout << "Enter final temp in kelven:  ";
			kel2 = resu.VDO();

			ans = (vol1* kel2) / kel1;
			cout << "the gass at " << kel2 << " will take up a space of " << ans << "L";
		}
		if(sel =="kel" ||sel =="Kel" ||sel =="KEL")
		{
			//double kel1, kel2, vol1, vol2, ans;
			cout << "Enter inical temp in kelven: ";
			kel2 = resu.VDO();
			cout << "Enter inical volume of gass: ";
			vol1 = resu.VDO();
			cout << "Enter final volume of gass:  ";
			vol2 = resu.VDO();

			ans = (vol1* kel2) / vol2;
			cout << "the gass at " << kel2 << " will take up a space of " << ans << "L";
		}
		if(sel =="cd"||sel =="CD")
			break;
		if(sel == "calc")
			resu.calc();

		if(sel =="clear"||sel =="Clear"||sel =="CLEAR")
			// cout << string(50,'\n');
			resu.clear();
		if(sel == "help"||sel == "Help"||sel == "HELP"||sel == "ls"||sel == "LS")
		{
			cout << "________________________________________________________\n"
				<< setw(15) << "vol" << setw(40) << "find volume of an ideal gas\n"
				<< setw(15) << "kel" << setw(40) << "find kelvin temprature of an ideal gas\n"
				<< setw(15) << "calc" << setw(40) << "simple calculater\n"
				<< setw(15) << "cd" << setw(40) << "exit\n"
				<< setw(15) << "clear" << setw(40) << "Clear screen\n";
		}
	}
}
//============================================================================================
void chem::boyllaw()
{
	double vol1, vol2, pres1, pres2, ans;
	string sel, raw;

	while(true){
		cout << "\nViper_Chem_BoylLaw: ";
		cin >> sel;
		resu.IN_History(sel);
		resu.univSelec(sel,sel);


		if(sel =="volch"||sel =="VolCh"||sel =="VOLCH")
		{
			cout << "    Enter inichal volume:  ";
			vol1 = resu.VDO();
			cout << "    Enter inical pressure: ";
			pres1 = resu.VDO();
			cout << "    Enter final presure:   ";
			pres2 =resu.VDO();

			vol2 = (vol1 * pres1) / pres2;
			cout << "\nFinal volume is: " << vol2 << endl;
		}
		if(sel =="presch"||sel =="PresCh"||sel =="PRESCH")
		{
			cout << "    Enter inichal volume:  ";
			vol1 = resu.VDO();
			cout << "    Enter inical pressure: ";
			pres1 = resu.VDO();
			cout << "    Enter final volume:    ";
			vol2 = resu.VDO();

			pres2 = (vol1 * pres1) / vol2;
			cout << "\nFinal volume is: " << pres2 << endl;
		}
		if(sel =="cd"||sel =="CD")
			break;
		if(sel == "calc")
			resu.calc();

		if(sel =="clear"||sel =="Clear"||sel =="CLEAR")
			// cout << string(50,'\n');
			resu.clear();
		if(sel == "help"||sel == "Help"||sel == "HELP"||sel == "ls"||sel == "LS")
		{
			cout << "________________________________________________________\n"
				<< setw(15) << "volch" << setw(40) << "find new volume of an ideal gas\n"
				<< setw(15) << "presch" << setw(40) << "find presure of an ideal gas\n"
				<< setw(15) << "calc" << setw(40) << "simple calculater\n"
				<< setw(15) << "cd" << setw(40) << "exit\n"
				<< setw(15) << "clear" << setw(40) << "Clear screen\n";
		}
	};
}
//============================================================================================
void chem::elecplat()
{
	double elec, atom, g, volt, time;
	string sel, raw;
	formula aloy;

	while(true){
		cout << "\nViper_Chem_Elecplat: ";
		cin >> sel;
		resu.IN_History(sel);
		resu.univSelec(sel,sel);


		cout << endl;
		if(sel =="time"||sel =="Time"||sel =="TIME")
		{
			cout << "    enter moles of -e:                ";
			elec = resu.VDO();
			cout << "    enter grames deposited:           ";
			g = resu.VDO();
			cout << "    enter atomic symbol/aloy formula: ";
			cin >> aloy;
			cout << "    enter the volts:                  ";
			volt = resu.VDO();

			time = (elec * g *(1/ aloy.mol())* 96485)/ volt;
			cout << "to deposit "<< g << "of material you must wait "<< time << "s\n";
		}
		if(sel =="atom"||sel =="Atom"||sel =="ATOM")
		{
			cout << "    enter moles of -e:           ";
			elec = resu.VDO();
			cout << "    enter grames deposited:      ";
			g = resu.VDO();
			cout << "    enter time for prosess:      ";
			time = resu.VDO();
			cout << "    enter the volts:             ";
			volt = resu.VDO();

			atom = 1/((time* volt) / (elec * g *96485));
			cout << "the atomic waight of deposited element is " << atom << endl;
		}
		if(sel =="gram"||sel =="Gram"||sel =="GRAM")
		{
			cout << "    enter moles of -e:                 ";
			elec = resu.VDO();
			cout << "    enter atomic symbol/ aloy formula: ";
			cin >> aloy;
			cout << "    enter time for prosess:            ";
			time = resu.VDO();
			cout << "    enter the volts:                   ";
			volt = resu.VDO();

			g = ((time* volt) / (96485 *(1 / aloy.mol())* elec));
			cout << "\nthe amout of deposited meterial is " << g << "g\n";
		}
		if(sel =="cd"||sel =="CD")
			break;
		if(sel == "calc")
			resu.calc();

		if(sel =="clear"||sel =="Clear"||sel =="CLEAR")
			// cout << string(50,'\n');
			resu.clear();
		if(sel == "help"||sel == "Help"||sel == "HELP"||sel == "ls"||sel == "LS")
		{
			cout << "________________________________________________________\n"
				<< setw(15) << "atom" << setw(40) << "find atomiMcass of electroplated mater\n"
				<< setw(15) << "gram" << setw(40) << "find grams of electroplat material\n"
				<< setw(15) << "time" << setw(40) << "find time to electroplate the object\n"
				<< setw(15) << "calc" << setw(40) << "simple calculater\n"
				<< setw(15) << "cd" << setw(40) << "exit\n"
				<< setw(15) << "clear" << setw(40) << "Clear screen\n";
		}
	}
}
//============================================================================================
void chem::ph()
{
	bool exem = true;
	double h, ph, poh, oh;
	char buffer[500];
	string sel, raw;

	cin.ignore(1);
	while (true){
		cout << "\nViper_Chem_pH: ";

		cin >> sel;
		resu.IN_History(sel);
		resu.univSelec(sel,sel);

		if(sel =="h-ph")
		{
			cout << "\n    [H] to pH\n"
				<< "    ______________________________________\n"
				<< "    enter h consentration: ";
			h = resu.VDO();

			ph = -1 * (log(h)/log(10));
			cout << "\nThe ph is " << ph << endl;
		}
		if(sel =="h-ph-a")
		{
			cout << "\n    [H] to pH\n"
				<< "    ______________________________________\n"
				<< "    enter h consentration: ";
			h = resu.VDO();

			ph = -1 * (log(h)/log(10));
			poh = 14 - ph;
			oh = pow(10, (-1 * poh));
			h = 0.00000000000001/oh;

			cout << " ______________________\n"
				<< "| pH <<  " << ph << endl
				<< "| pOH << " << poh << endl
				<< "| [OH] <<  " << oh << endl
				<< "| [h] <<   " << h << endl;
		}
		if(sel =="ph-poh"||sel =="pH-pOH"||sel =="PH-POH")
		{
			cout << "\n    pH to pOH\n"
				<< "    ______________________________________\n"
				<< "    enter pH: ";
			ph = resu.VDO();

			if(ph >14 || ph < 0)
			{
				cout << "\a--INVALID ENTRY--";
				break;
			}

			poh = 14-ph;
			cout << "\npOH is " << poh << endl;
		}
		if(sel =="ph-poh-a")
		{
			cout << "\n    pH to pOH\n"
				<< "    ______________________________________\n"
				<< "    enter pH: ";
			ph = resu.VDO();

			if(ph >14 || ph < 0)
			{
				cout << "\a--INVALID ENTRY--";
				break;
			}

			poh = 14-ph;
			oh = pow(10,(-1 * poh));
			h = 0.00000000000001/oh;
			ph = -1 * (log(h)/log(10));

			cout << " ______________________\n"
				<< "| pOH << " << poh << endl
				<< "| OH <<  " << oh << endl
				<< "| h <<   " << h << endl
				<< "| pH <<  " << ph << endl;
		}
		if(sel =="poh-oh"||sel =="pOH-OH"||sel =="POH-OH")
		{
			cout << "\n    pOH to [OH]\n"
				<< "    ______________________________________\n"
				<< "    enter pOH: ";
			poh = resu.VDO();

			if(ph >14 || ph < 0)
			{
				cout << "\a--INVALID ENTRY--";
				break;
			}

			oh = pow(10,poh);
			cout << "\nthe OH consentration is " << oh << endl;
		}
		if(sel =="poh-oh-a")
		{
			cout << "\n    pOH to [OH]\n"
				<< "    ______________________________________\n"
				<< "    enter pH: ";
			poh = resu.VDO();

			if(ph >14 || ph < 0)
			{
				cout << "\a--INVALID ENTRY--";
				break;
			}

			oh = pow(10,(-1 * poh));
			h = 0.00000000000001/oh;
			ph = -1 * (log(h)/log(10));
			poh = 14-ph;

			cout << " ______________________\n"
				<< "| Oh <<  " << oh << endl
				<< "| h <<   " << h << endl
				<< "| ph <<  " << ph << endl
				<< "| pOh << " << poh<< endl;
		}
		if(sel =="oh-h"||sel =="OH-h"||sel =="OH-H")
		{
			cout << "\n    [OH] to [H]\n"
				<< "    ______________________________________\n"
				<< "    enter [OH]: ";
			oh = resu.VDO();

			h = 0.00000000000001/oh;
			cout << "\nconsentration of [H] is " << h << endl;
		}
		if(sel =="oh-h-a")
		{
			cout << "\n    [OH] to [H]\n"
				<< "    ______________________________________\n"
				<< "    enter [OH]: ";
			oh = resu.VDO();

			h = 0.00000000000001/oh;
			ph = -1 * (log(h)/log(10));
			poh = 14-ph;
			oh = pow(10,(-1 * poh));

			cout << " ______________________\n"
				<< "| h <<   " << h << endl
				<< "| ph <<  " << ph << endl
				<< "| pOh << " << poh << endl
				<< "| Oh <<  " << oh << endl;
		} 
		if(sel == "help"||sel == "ls")
		{
			cout << "________________________________________________________\n" 
				<< setw(15) << "h-ph" << " " << setw(40) << "find ph from [H] -a to find all values\n"
				<< setw(15) << "ph-poh" << " " << setw(40) << "find pOH from pH -a to find all values\n"
				<< setw(15) << "poh-oh" << " " << setw(40) << "find [OH] from pOH -a to find all values\n"
				<< setw(15) << "oh-h" << " " << setw(40) << "find [H] from [OH] -a to find all values\n"
				<< setw(15) << "calc" << setw(40) << "simple calculater\n"
				<< setw(15) << "clear" << " " << setw(40) << "Clear screen\n"
				<< setw(15) << "cd"<< " " << setw(40) << "Exit program\n";
		}
		if(sel =="cd"||sel =="CD")
			break;
		if(sel == "calc")
			resu.calc();

		if(sel =="clear")
			resu.clear();// cout << string(50,'\n'); 
	}
}
//============================================================================================
void chem::idelgas()
{
	double mol,atm,atm2,kelv,kelv2,vol,vol2;
	string sel, raw;
	while (true){
		cout << "\nViper_Chem_IdelGas: ";
		cin >> sel;
		resu.IN_History(sel);
		resu.univSelec(sel,sel);



		if(sel == "mol"||sel == "Mol"||sel == "MOL")
		{
			cout << "    enter atmosphears:   ";
			atm = resu.VDO();
			cout << "    enter tem in kelvens ";
			kelv = resu.VDO();
			cout << "    enter volume:        ";
			vol = resu.VDO();

			mol = (atm * vol) / (kelv * 0.082057);
			cout << "the moles of the gass present is: " << mol << endl;
		}
		if(sel == "kelv"||sel == "kelven")
		{
			cout << "    enter atmosphears:     ";
			atm = resu.VDO();
			cout << "    enter the mols present ";
			mol = resu.VDO();
			cout << "    enter volume:          ";
			vol = resu.VDO();

			kelv = (atm * vol) / (mol * 0.082057);
			cout << "the kelven temprature is "<< kelv << endl;
		}
		if(sel == "vol2ig"||sel == "Vol2ig"||sel == "Vol2IG"||sel == "VOL2IG")
		{
			cout << "    enter atmosphears:     ";
			atm = resu.VDO();
			cout << "    enter atmosphears:     ";
			atm2 = resu.VDO();
			cout << "    enter temp in kelvens  ";
			kelv = resu.VDO();
			cout << "    enter temp in kelvens  ";
			kelv2 = resu.VDO();
			cout << "    enter volume:          ";
			vol = resu.VDO();

			vol2 = (kelv2 * atm *vol) / (kelv * atm2);
			cout << "final volume of gas is " << vol2<< endl;
		}
		if(sel == "atm"||sel == "Atm"||sel == "ATM")
		{
			cout << "    enter temp in kelvens  ";
			kelv = resu.VDO();
			cout << "    enter the mols present ";
			mol =resu.VDO();
			cout << "    enter volume:          ";
			vol = resu.VDO();

			atm = (mol * kelv * 0.082057) / vol;
			cout << "the presure of gas is " << atm << endl;
		}
		if(sel == "vol"||sel == "Vol"||sel == "VOL")
		{
			cout << "    enter temp in kelvens  ";
			kelv = resu.VDO();
			cout << "    enter the mols present ";
			mol = resu.VDO();
			cout << "    enter atmosphears:     ";
			atm = resu.VDO();

			vol = (mol * kelv * 0.082057) / atm;
			cout << "the volume of gas is " << vol << endl;
		}
		if(sel == "help"||sel == "Help"||sel == "HELP"||sel == "ls"||sel == "LS")
		{
			cout << "________________________________________________________\n" 
				<< setw(15) << "atm" << setw(40) << "find presure of ideal gas\n"
				<< setw(15) << "mol" << setw(40) << "find moles of ideal gas\n"
				<< setw(15) << "kelv" << setw(40) << "find temp of ideal gas\n"
				<< setw(15) << "vol" << setw(40) << "find volume of ideal gas\n"
				<< setw(15) << "vol2ig" << setw(40) << "find second volume of ideal gas\n"
				<< setw(15) << "calc" << setw(40) << "simple calculater\n"
				<< setw(15) << "clear" << setw(40) << "Clear screen\n"
				<< setw(15) << "cd"<< setw(40) << "Exit program\n";
		}
		if(sel =="cd"||sel =="CD")
			break;
		if(sel == "calc")
			resu.calc();

		if(sel =="clear"||sel =="Clear"||sel =="CLEAR")
			resu.clear();// cout << string(50,'\n');
	}
}
//============================================================================================
void chem::titrate()
{
	double titrate,
	       mmH,   vol,
	       rate,  ans,
	       Acon,  Bcon,
	       VA,    VB,
	       Ka,    kb,
	       Srate, a;
	string sel, raw;
	while (true){
		cout << "\nViper_Chem_AutoTitratior: ";
		cin >> sel;
		resu.IN_History(sel);
		resu.univSelec(sel,sel);


		if(sel == "wacidsbase"){
			cout << "    Enter the Acid volume(ml): ";
			VA = resu.VDO(); //
			cout << "    Enter the concentration of Acid: ";
			Acon = resu.VDO(); //
			cout << "    Enter the Base volume(ml): ";
			VB = resu.VDO(); //
			cout << "    Enter the concentration of Base: ";
			Bcon = resu.VDO(); //
			cout << "    Enter the Ka of Acid: ";
			Ka = resu.VDO(); //
			cout << "    Enter the volume(ml) of Base to be added in each titration: ";
			rate = resu.VDO(); //
			Srate = rate;
			cout << "--------------------------------------------------------------\n";

			do
			{
				vol = VA + rate;
				mmH = (VA * Acon) - (rate * Bcon);

				a = Ka * (mmH / (rate * Bcon));

				titrate = abs(log (a) / (log (10)));
				cout << rate << " ml\t " << titrate << " PH"<< endl;
				rate = rate + Srate;

			}while (titrate < 7);
			if (rate < VB)
			{
				do
				{
					vol = VA + rate;
					mmH = ((rate * Bcon)-(VA * Acon));

					a =(mmH / (vol));

					titrate = abs(log (1e-14/a) / (log (10)));

					cout << rate << " ml\t " << titrate << " PH"<< endl;
					rate = rate + Srate;
				}while (rate <= VB);}

		}
		if(sel == "sacidsbase"){
			cout << "    Enter the Acid volume(ml): ";
			VA = resu.VDO(); //
			cout << "    Enter the concentration of Acid: ";
			Acon = resu.VDO(); //
			cout << "    Enter the Base volume(ml): ";
			VB = resu.VDO(); //
			cout << "    Enter the concentration of Base: ";
			Bcon = resu.VDO(); //
			cout << "    Enter the volume(ml) of Base to be added in each titration: ";
			rate = resu.VDO(); //
			Srate = rate;
			cout << "--------------------------------------------------------------\n";
			do
			{
				vol = VA + rate;
				mmH = (VA * Acon) - (rate * Bcon);

				titrate = abs(log (mmH/vol)) / (log (10));

				cout << rate << " ml\t " << titrate << " PH"<< endl;
				rate = rate + Srate;
			}while (titrate < 7);
			if (rate < VB){
				do
				{
					vol = VA + rate;
					mmH = ((rate * Bcon)-(VA * Acon));

					a =(mmH / (vol));

					titrate = abs(log (1e-14/a) / (log (10)));

					cout << rate << " ml\t " << titrate << " PH"<< endl;
					rate = rate + Srate;
				}while (rate <= VB);
			}
		}
		if(sel == "weakbase"){
			cout << "    Enter the Acid volume(ml): ";
			VA = resu.VDO(); // checks if user typed a number 
			cout << "    Enter the concentration of Acid: ";
			Acon = resu.VDO();
			cout << "    Enter the Base volume(ml): ";
			VB = resu.VDO();
			cout << "    Enter the concentration of Base: ";
			Bcon = resu.VDO();
			cout << "    Enter the Kb of Base" << endl;
			raw = resu.VDO();
			cout << "    Enter the volume(ml) of Base to be added in each titration: ";
			rate = resu.VDO();
			Srate = rate;
			cout << "--------------------------------------------------------------\n";
			do
			{
				vol = VB + rate;
				mmH = (rate * Bcon) - (VA * Acon);

				a = kb * (mmH / vol);

				titrate = 14- (abs(log (a) / (log (10))));
				cout << rate << " ml\t " << titrate << " PH"<< endl;
				rate = rate + Srate;

			}while (titrate > 7);
			if (rate < VB){
				VA = VA - VB;
				do
				{
					vol = VA + rate;
					mmH = (VA * Acon) - (rate * Bcon);

					titrate = abs(log (mmH/vol)) / (log (10));

					cout << rate << " ml\t " << titrate << " PH"<< endl;
					rate = rate + Srate;
				}while (titrate < 7);}
		}
		if(sel == "help"||sel == "Help"||sel == "HELP"||sel == "ls"||sel == "LS")
		{
			cout << "________________________________________________________\n" 
				<< setw(15) << "weakbase"<< setw(40) << "titrate weak base and strong acid\n"
				<< setw(15) << "weekacid" << setw(40) << "titrate weak acid and strong base\n"
				<< setw(15) << "sacidsbase" << setw(40) << "titrate strong acid and strong base\n"
				<< setw(15) << "calc" << setw(40) << "simple calculater\n"
				<< setw(15) << "clear" << setw(40) << "Clear screen\n"
				<< setw(15) << "cd"<< setw(40) << "Exit program\n";
		}
		if(sel =="cd"||sel =="CD")
			break;
		if(sel == "calc")
			resu.calc();

		if(sel =="clear"||sel =="Clear"||sel =="CLEAR")
			resu.clear();// cout << string(50,'\n');
	}
}
//============================================================================================
void chem::stoichiometry()
{ 
	char arr[2];
	bool pass=false, exitIf = false;
	float elWeight[20];
	double *ele, *elW, *elemets,
	       *tempDouble;
	double mol, INDEX =0, limitR;
	string *elName, *tempString;
	string eleSymb[20], sel, RAW, copy;
	int index = 0, LOCAL = INDEX-1,
	    count, numReac=1;

	while (true){
		cout << "\nViper_Chem_Stoichiometry: ";
		cin >> sel;
		resu.IN_History(sel);
		resu.univSelec(sel,sel);


		if(sel =="molformla"){
			cout << "\n    Enter molar mass of molocule:         ";
			mol = resu.VDO();
			cout << "    Enter number of elemtnt(SYMBOLS) in compound: ";
			index = resu.VInt();
			elemets = new double[index];
			for(int u =0; u < index; u ++){
				cout << "    Enter element symbol (case senitive): ";
				cin >> eleSymb[u];
				for(int x =0; x < 119; x++)
				{
					if(pt[x].name == eleSymb[u])
					{
						elWeight[u] = pt[x].w;
						break;
					}
				}
				cout << "    Enter precent of this element:        ";
				elemets[u] = resu.VDO();
			}
			for(int u =0; u < index; u ++){
				int syscash;

				elemets[u] = (elemets[u] / 100) * mol;
				elemets[u] = elemets[u] * (1 / elWeight[u]);
				syscash = ((int(elemets[u]))+1);
				if((elemets[u] + 0.5) >= syscash)
					elemets[u] = int(elemets[u]) + 1;
				else
					elemets[u] = int(elemets[u]);
				if(elemets[u] == 0)
					elemets[u] = 1;
			}
			cout << "the compounds moleculer fomula is: \n";
			for(int u =0; u < index; u ++)
				cout << setw(2) << eleSymb[u] << "  ";
			cout << endl;
			for(int u =0; u < index; u ++)
				cout << setw(4) << elemets[u];
			cout << endl;
			delete [] elemets;
		}
		if(sel == "molmas")
		{
			mol = 0;
			cout << "\n    Enter the formula of the compound: ";
			cin >> RAW;

			mol = do_MOL_mas(RAW);

			cout << "the molar weight of the compound is: " << mol << endl;
			mol = 0;
		}

		if(sel =="masprnt"){
			cout << "\n    Enter the molecular formula: ";
			cin >> RAW;

			mol = do_MOL_mas(RAW);
			index = do_SYM_count(RAW);
			ele = do_ELE_weigh(RAW); // gets weight of element groups eg: N2 or Cu3
			elName = do_BREAK_formula(RAW, index); // brakes formula into individual symbols

			elemets = new double[index];

			///////////////////////////////////////////////////////////////////////////////////

			for(int u =0; u < index; u++)
				elemets[u] = (ele[u] / mol) * 100; // get mass precent of eatch element
			cout << " _______________________________________________\n";


			LOCAL = index-1;
			for(int u =0; u < index; u++)
			{
				for(int N=0; N<119; N++)
				{
					if(elName[u] != pt[N].name) // checks for blank or empty arrays
						pass = false;
					else
					{
						pass = true;
						break;
					}
				}
				LOCAL--;
				if(pass == true)
					cout << "|The mass precent of "<< setw(4) << elName[u] 
						<< " is " << elemets[u] << "%"<< endl;
			}
			delete [] ele;   // prevents memory leakagei
			delete [] elemets;
			delete [] elName;
		}
		if(sel == "limreac")
		{
			count = 1;
			cout << "    Enter the balanced equation of the reaction:\n";
			cin.ignore(1);
			getline(cin, RAW);

			for(int i=0; i< RAW.size(); i++)
			{
				if(RAW[i] == ' '|| RAW[i] == '='|| RAW[i] =='+')
					count++;
			}

			elName = new string [count];
			elW = new double [count];

			for(int u=0; RAW[u] != '='; u++)
				if(RAW[u] == '+')
					numReac++;

			// decompose balanced equation and get individual elements
			copy = RAW;
			for(int u=0; u< count; u++)
			{
				for(int i=0; i<copy.size(); i++)
				{
					// if there is no + or = then get watever  in coppy
					if(copy[i+1] == '\0')
					{
						elName[u] = copy;
						count = u+1;
						break;
					}
					// if the formula includes + or = then brake off the compound
					// and save in elName array
					if(copy[i] == '+'||copy[i] == '=')
					{
						copy.erase(i);
						elName[u] = copy;

						RAW.erase(0, (i+1));
						copy = RAW;

						break;
					}
				} 
			}
			ele = new double[count];
			// get rid of any spaces in molecular formula 
			for(int u=0; u< count; u++)
			{
				copy = elName[u];
				for(int i=0; i< copy.size(); i++)
					if(copy[i] == ' ')
						copy.erase(i,1);
				elName[u] = copy;
			}
			// get number of individual compounds
			for(int u=0; u< count; u++)
			{
				copy = elName[u];
				if(copy[0] >= '1'&&copy[0] <='9')
				{
					arr[0] = copy[0];
					copy.erase(0,1);
					if(copy[0] >= '1'&&copy[0] <='9')
					{
						arr[1] = copy[0];
						copy.erase(0,1);
					}
					ele[u] = strtod(arr,NULL);
				}
				else
					ele[u] = 1;
				elName[u] = copy;
			}
			// get moler mass of each compound
			for(int u=0; u< count; u++)
				elW[u] = do_MOL_mas(elName[u]);

			// get grams used in this reaction
			for(int i=0; i< numReac; i++)
			{
				cout << "    Enter the grams of " << elName[i] << " used: ";
				elWeight[i] = resu.VDO();
			}

			//REAL CALCULATION
			// get moles of each compound
			for(int i=0; i< numReac; i++)
				elWeight[i] = elWeight[i] / elW[i];

			mol = elWeight[0] * (ele[1] / ele[0]);

			// get grames of product //////////////////////
			if(mol > elWeight[1])
				limitR = elWeight[0] * (ele[1] / ele[0]);

			if(mol > elWeight[1])
				limitR = elWeight[1] * (ele[0] / ele[1]);


			cout << "________________________________________________________\n"; 
			if(mol > elWeight[1])
				cout << "\nThe limiting reactent is: " << elName[1] << endl;
			else
				cout << "\nThe limiting reactent is: " << elName[0] << endl;

			numReac =1;
			delete [] elName;
			delete [] ele;
			delete [] elW;
		}
		if(sel == "help"||sel == "ls")
		{
			cout << "________________________________________________________\n" 
				<< setw(15) << "molformla"<< setw(40) << "find muleculer formula\n"
				<< setw(15) << "masprnt"<< setw(40) << "find mass precent of the compound\n"
				<< setw(15) << "molmas" << setw(40) << "find molar mass of compound\n"
				<< setw(15) << "limreac" << setw(40) << "find limiting reactant\n"
				<< setw(15) << "calc" << setw(40) << "simple calculater\n"
				<< setw(15) << "clear" << setw(40) << "Clear screen\n"
				<< setw(15) << "cd"<< setw(40) << "Exit program\n";
		}
		if(sel =="cd")
			break;
		if(sel == "calc")
			resu.calc();

		if(sel =="clear")
			resu.clear();// cout << string(50,'\n');
	}
}

//============================================================================================
void chem::calc()
{
	double ans, num1, num2;
	string mod;

	cin >> num1;
	cin >> mod;


	if(mod == "tan"||mod == "sin"||mod == "cos"||
			mod == "rtan"||mod == "rsin"||mod == "rcos"||
			mod == "arctan"||mod == "arcsin"||mod == "arccos"||
			mod == "log"||mod == "ln"||mod == "log10"||mod == "e"||
			mod == "sqrt")
	{
		if(mod == "tan")
		{ans = tan(num1 *(pi/180));}
		else if(mod == "cos")
		{ans = cos(num1 *(pi/180));}
		else if(mod == "sin")
		{ans = sin(num1 *(pi/180));}

		else if(mod == "arctan")
		{ans = tan(num1) *(180/pi);}
		else if(mod == "arccos")
		{ans = cos(num1) *(180/pi);}
		else if(mod == "arcsin")
		{ans = sin(num1) *(180/pi);}

		else if(mod == "rtan")
		{ans = tan(num1);}
		else if(mod == "rcos")
		{ans = cos(num1);}
		else if(mod == "rsin")
		{ans = sin(num1);}

		else if(mod == "log")
		{ans = log(num1 )/ log(10);}
		else if(mod == "ln")
		{ans = log(num1);}
		else if(mod == "log10")
		{ans = pow(10,num1);}
		else if(mod == "e")
		{ans = pow(2.718281828,num1);}
		else if(mod == "sqrt")
		{ans = sqrt(num1);}
	}
	if(mod == "-"||mod == "+"||mod == "/"||mod == "*")
	{
		cin >> num2;
		if(mod == "+")
		{ans = num1 + num2;}
		else if(mod == "-")
		{ans = num1 - num2;}
		else if(mod == "*")
		{ans = num1 * num2;}
		else if(mod == "/")
		{ans = num1 / num2;}
		else
			return;
	}
	cout << "\n" << ans << endl;
}

//============================================================================================
void chem::eqlprsur()
{
	string sel;
	double e1,e2, product, con, ans,
	       vol, mol,
	       r[50], p[50];
	int check, check2;

	while (true){
		cout << "\nViper_Chem_Equilibrium: ";
		cin >> sel;
		resu.IN_History(sel);
		resu.univSelec(sel,sel);

		if(sel =="eqlpres1")
		{
			cout << "    Enter equilibrium constant: ";
			con = resu.VDO();


			cout << "    Enter number of reactant compounds:   ";
			check = resu.VInt();
			//=========================================================
			//reactants
			check = check -1;
			for(int i=0; i < check; i++)
			{
				cout << "  Enter compound "<< i+1 <<" presure: ";
				r[i] = resu.VDO();
			}
			cout << "    Enter number of products compounds:   ";
			check2 = resu.VInt();
			//=========================================================
			//products
			for(int i=0; i< check2; i++)
			{
				cout << "  Enter compound "<< i+1 <<" presure: ";
				p[i] = resu.VDO();
			}
			//==========================================================
			e1 = 1;
			for(int i=0; i< check; i++)
			{
				e1 = r[i] * e1;
			}
			product = 1;
			for(int i=0; i< check2; i++)
			{
				product = p[i] * product;
			}
			////////////////////////////////////////////////////////////////////////

			ans = sqrt(con * product) / e1;


			cout << "\nReactant presure is " << ans << " \n";
		}
		if(sel =="eqlpres2")
		{
			cout << "    Enter equilibrium constant: ";
			con = resu.VDO();


			cout << "    Enter number of reactant compounds:   ";
			check = resu.VInt();
			//=========================================================
			//reactants
			for(int i=0; i< check; i++)
			{
				cout << "  Enter compound "<< i+1 <<" presure: ";
				r[i] = resu.VDO();
			}
			cout << "    Enter number of products compounds:   ";
			check2 = resu.VInt();
			//=========================================================
			//reactants
			for(int i=0; i< check2; i++)
			{
				cout << "  Enter compound "<< i+1 <<" presure: ";
				p[i] = resu.VDO();
			}
			//==========================================================
			e1 = 1;
			for(int i=0; i< check; i++)
			{
				e1 = r[i] * e1;
			}
			product = 1;
			for(int i=0; i< check2; i++)
			{
				product = p[i] * product;
			}
			////////////////////////////////////////////////////////////////////////

			ans = pow(product,2) / e1;

			if(ans > con)
			{
				cout << ans << " > " << con << endl;
				cout << "\nSystem will shift to the left\n";
			}
			else
			{
				cout << ans << " < " << con << endl;
				cout << "\nSystem will shift to the right\n";
			}
		}
		if(sel == "eqlvol")
		{
			cout << "    Enter equilibrium constant:           ";
			con = resu.VDO();
			cout << "    Enter volume of contaner:             ";
			vol = resu.VDO();
			cout << "    Enter number of reactant compounds:   ";
			check = resu.VInt();
			//=========================================================
			//reactants
			for(int i=0; i<  check; i++)
			{
				cout << "  Enter mol of reactant "<< i+1 <<" : ";
				r[i] = resu.VDO();
				r[i] = r[i] / vol;
			}
			//=========================================================
			//products
			cout << "    Enter number of product compounds:  ";
			check2 = resu.VInt();
			for(int i=0; i< check2; i++)
			{
				cout << "  Enter mol of reactant "<< i+1 <<" : ";
				p[i] = resu.VDO();
				p[i] = p[i] / vol;
			}
			//=========================================================
			//products
			e1 = 1;
			for(int i=0; i< check2; i++)
			{
				e1 = p[i] * e1;
			}
			//=========================================================
			//reactants
			e2 = 1;
			for(int i=0; i< check2; i++)
			{
				e2 = r[i] * e2;
			}
			///////////////////////////////////////////
			ans = e1 / e2;

			if(ans > con)
			{
				cout << ans << " > " << con << endl;
				cout << "\nSystem will shift to the left\n";
			}
			else
			{
				cout << ans << " < " << con << endl;
				cout << "\nSystem will shift to the right\n";
			}
		}
		if(sel == "help"||sel == "ls")
		{
			cout << "________________________________________________________\n" 
				<< setw(15) << "eqlpres1"<< setw(40) << "find reactant equilibrium by presure\n"
				<< setw(15) << "eqlpres2"<< setw(40) << "calculate equilibrium by presure\n"
				<< setw(15) << "eqlvol" << setw(40) << "calculate equilibrium by volume\n"
				<< setw(15) << "calc" << setw(40) << "simple calculater\n"
				<< setw(15) << "clear" << setw(40) << "Clear screen\n"
				<< setw(15) << "cd"<< setw(40) << "Exit program\n";
		}
		if(sel =="cd")
			break;
		if(sel == "calc")
			resu.calc();

		if(sel =="clear")
			resu.clear();// cout << string(50,'\n');
	}
}
//============================================================================================
void chem::frzpoint()
{
	string sel, ref;
	double temp, table, mass, mol, ans;

	while (true){
		cout << "\nViper_Chem_FrezingPointDepression: ";
		cin >> sel;
		resu.IN_History(sel);
		resu.univSelec(sel,sel);


		if(sel == "molfc")
		{
			cout << "    Enter new frezing temp:    ";
			temp = resu.VDO();
			cout << "    Enter mass of solution:    ";
			mass = resu.VDO();
			cout << "    Enter molar mass of solut: ";
			mol = resu.VDO();
			cout << "    Enter solution:            ";
			cin.get();
			getline(cin,ref);

			if(temp < 0)
			{
				temp = abs(temp);
			}
			//-------------------------------------------------------------------------
			if(ref == "water"||ref =="h2o")
			{
				ref = "water";
			}
			if(ref == "carbontetrachloride"||ref == "carbon tetrachloride"||ref =="ccl44")
			{
				ref = "carbonTetrachloride";
			}
			if(ref == "chloroform"||ref == "chcl3")
			{
				ref = "chloroform";
			}
			if(ref == "benzene"||ref =="c6h6")
			{
				ref = "benzene";
			}
			if(ref == "corbondisulfide"||ref == "corbon disulfide"||ref =="cs2")
			{
				ref = "corbonDisulfide";
			}
			if(ref == "ethylether"||ref == "ethyl ether"||ref =="c4h10o")
			{
				ref = "ethylEther";
			}
			if(ref == "camphor"||ref =="c10h16o")
			{
				ref = "camphor";
			}
			//-------------------------------------------------------------------------
			for(int i=0; i< 30; i++)
			{
				if(ref == k[i].name)
					table = k[i].kf;
			}

			ans = temp / table;
			ans = ans * mass;
			ans = ans * mol;

			cout << "the mas of solute neded is: " << ans << "g\n";
		}
		if(sel == "molff"||sel == "MolFF"||sel == "MOLFF")
		{
			cout << "    Enter new frezing temp:    ";
			temp = resu.VDO();
			cout << "    Enter mass of solution:    ";
			mass = resu.VDO();
			cout << "    Enter molar mass of solut: ";
			mol = resu.VDO();
			cout << "    Enter solution:            ";
			cin.get();
			getline(cin,ref);

			temp = ((temp - 32) * 5) / 9;

			if(temp < 0)
			{
				temp = abs(temp);
			}
			//-------------------------------------------------------------------------
			if(ref == "water"||ref =="h20")
			{
				ref = "water";
			}
			if(ref == "carbontetrachloride"||ref == "carbon tetrachloride"||ref =="ccl44")
			{
				ref = "carbonTetrachloride";
			}
			if(ref == "chloroform"||ref == "chcl3")
			{
				ref = "chloroform";
			}
			if(ref == "benzene"||ref =="c6h6")
			{
				ref = "benzene";
			}
			if(ref == "corbondisulfide"||ref == "corbon disulfide"||ref =="cs2")
			{
				ref = "corbonDisulfide";
			}
			if(ref == "ethylether"||ref == "ethyl ether"||ref =="c4h10o")
			{
				ref = "ethylEther";
			}
			if(ref == "camphor"||ref =="c10h16o")
			{
				ref = "camphor";
			}
			//-------------------------------------------------------------------------
			for(int i=0; i< 30; i++)
			{
				if(ref == k[i].name)
					table = k[i].kf;
			}

			ans = temp / table;
			ans = ans * mass;
			ans = ans * mol;

			cout << "the mas of solute neded is: " << ans << "g\n";
		}
		if(sel == "help"||sel == "Help"||sel == "HELP"||sel == "ls"||sel == "LS")
		{
			cout << "________________________________________________________\n" 
				<< setw(15) << "molfc"<< setw(40) << "find new frezzing point in celceus\n"
				<< setw(15) << "vmolff" << setw(40) << "find new frezzing point in Fahrenheit\n"
				<< setw(15) << "calc" << setw(40) << "simple calculater\n"
				<< setw(15) << "clear" << setw(40) << "Clear screen\n"
				<< setw(15) << "cd"<< setw(40) << "Exit program\n";
		}
		if(sel =="cd"||sel =="CD")
			break;
		if(sel == "calc")
			resu.calc();

		if(sel =="clear"||sel =="Clear"||sel =="CLEAR")
			clear();// cout << string(50,'\n');
	}
}
//
//
////////////////////////////////////////////////////////////////////////////////
//
//
void chem::meters()
{
	string sel;
	double ft, m;
	while (true){
		cout << "\nViper_Chem_Meter-Conversion: ";
		cin >> sel;
		resu.IN_History(sel);
		resu.univSelec(sel,sel);


		if(sel == "mtof")
		{
			cout << "\n    Enter the number of meters: ";
			m = resu.VDO();

			ft = m / 0.3048;
			cout << " ________________________________\n"
				<< "|     Feet " << ft << endl << endl;
		}
		if(sel == "ftom")
		{
			cout << "\n    Enter the number of feet: ";
			ft = resu.VDO();

			m = ft / 3.281;
			cout << " ________________________________\n"
				<< "|     Meters " << m << endl << endl;
		}
		if(sel == "mtoin")
		{
			cout << "\n    Enter the number of Meters: ";
			m = resu.VDO();

			ft = m / 39.37;
			cout << " ________________________________\n"
				<< "|     inches " << ft << endl<< endl;
		}
		if(sel == "help"||sel == "Help"||sel == "HELP"||sel == "ls"||sel == "LS")
		{
			cout << "________________________________________________________\n" 
				<< setw(15) << "mtof"<< setw(40) << "Convert metters to feet\n"
				<< setw(15) << "ftom" << setw(40) << "Convert feet to metters\n"
				<< setw(15) << "mtoin" << setw(40) << "Convert metters to inches\n"
				<< setw(15) << "calc" << setw(40) << "simple calculater\n"
				<< setw(15) << "clear" << setw(40) << "Clear screen\n"
				<< setw(15) << "cd"<< setw(40) << "Exit program\n";
		}
		if(sel =="cd"||sel =="CD")
			break;
		if(sel == "calc")
			resu.calc();

		if(sel =="clear"||sel =="Clear"||sel =="CLEAR")
			resu.clear();// cout << string(50,'\n');
	}
}
//============================================================================================
void chem::milklm()
{
	string sel;
	double m, k;
	while (true){
		cout << "\nViper_Chem_Distance-Conversion: ";
		cin >> sel;
		resu.IN_History(sel);
		resu.univSelec(sel,sel);


		if(sel == "ktom"||sel == "KtoM"||sel == "KTOM")
		{
			cout << "\n    Enter kilometer distance: ";
			k = resu.VDO();

			m = k *  0.621371192;
			cout << "the mile distance is: " << m << endl;
		}
		if(sel == "mtok"||sel == "MtoK"||sel == "MTOK")
		{
			cout << "\n    Enter mile distance: ";
			m = resu.VDO();

			k = m * 1.609344;
			cout << "the kilometer distance is: " << m << endl;
		}
		if(sel == "help"||sel == "Help"||sel == "HELP"||sel == "ls"||sel == "LS")
		{
			cout << "________________________________________________________\n" 
				<< setw(15) << "ktom"<< setw(40) << "Convert metters to feet\n"
				<< setw(15) << "mtok" << setw(40) << "Convert feet to metters\n"
				<< setw(15) << "calc" << setw(40) << "simple calculater\n"
				<< setw(15) << "clear" << setw(40) << "Clear screen\n"
				<< setw(15) << "cd"<< setw(40) << "Exit program\n";
		}
		if(sel =="cd"||sel =="CD")
			break;
		if(sel == "calc")
			resu.calc();

		if(sel =="clear"||sel =="Clear"||sel =="CLEAR")
			resu.clear();// cout << string(50,'\n');
	}
}
//============================================================================================
void chem::energy()
{
	string sel;
	double m, k;
	while (true){
		cout << "\nViper_Chem_Energy-Conversion: ";
		cin >> sel;
		resu.IN_History(sel);
		resu.univSelec(sel,sel);


		if(sel == "ctoj"||sel == "CToJ"||sel == "CTOJ")
		{
			cout << "    Enter total calories: ";
			k = resu.VDO();

			m = k * 4.186;
			cout << "total number of juels is " << m <<endl;
		}
		if(sel == "jtoc"||sel == "JToC"||sel == "JTOC")
		{
			cout << "    Enter total joules: ";
			k = resu.VDO();

			m = k / 4.186;
			cout << "total number of calories is " << m <<endl;
		}
		if(sel == "help"||sel == "Help"||sel == "HELP"||sel == "ls"||sel == "LS")
		{
			cout << "________________________________________________________\n" 
				<< setw(15) << "ctoj"<< setw(40) << "Convert calories to joules\n"
				<< setw(15) << "jtoc" << setw(40) << "Convert joules to calories\n"
				<< setw(15) << "calc" << setw(40) << "simple calculater\n"
				<< setw(15) << "clear" << setw(40) << "Clear screen\n"
				<< setw(15) << "cd"<< setw(40) << "Exit program\n";
		}
		if(sel =="cd"||sel =="CD")
			break;
		if(sel == "calc")
			resu.calc();

		if(sel =="clear"||sel =="Clear"||sel =="CLEAR")
			resu.clear();// cout << string(50,'\n');
	}
}
//============================================================================================
void chem::temp()
{
	double k, c, f;
	string eleSymb[20], sel;

	while (true){
		cout << "\nViper_Chem_Temp-Converter: ";
		cin >> sel;
		resu.IN_History(sel);
		resu.univSelec(sel,sel);


		if(sel == "far"||sel == "Far"||sel == "FAR")
		{
			cout << "\n    Enter Fahrenheit degree: ";
			f = resu.VDO();

			c = ((f - 32) * 5) / 9;
			k = c + 273;
			cout << " Fahrenheit " << f << endl
				<< " Celsius    " << c << endl
				<< " kelvin     " << k << endl;
		}
		if(sel == "cel"||sel == "Cel"||sel == "CEL")
		{
			cout << "\n    Enter Celsius degree: ";
			c = resu.VDO();

			f = (c * 1.8) + 32;
			k = c + 273;
			cout << " Celsius    " << c << endl
				<< " Fahrenheit " << f << endl
				<< " kelvin     " << k << endl;
		}
		if(sel == "kel"||sel == "Kel"||sel == "KEL")
		{
			cout << "\n    Enter Kelvin degree: ";
			k = resu.VDO();

			c = k - 273;
			f = (c * 1.8) + 32;
			cout << " kelvin     " << k << endl
				<< " Fahrenheit " << f << endl
				<< " Celsius    " << c << endl;
		}
		if(sel == "help"||sel == "Help"||sel == "HELP"||sel == "ls"||sel == "LS")
		{
			cout << "________________________________________________________\n" 
				<< setw(15) << "cel"<< setw(40) << "Convert Fahrenheit to C and K\n"
				<< setw(15) << "far" << setw(40) << "Convert Celsius to F and K\n"
				<< setw(15) << "kel" << setw(40) << "Convert Kelvin to C and F\n"
				<< setw(15) << "calc" << setw(40) << "simple calculater\n"
				<< setw(15) << "clear" << setw(40) << "Clear screen\n"
				<< setw(15) << "cd"<< setw(40) << "Exit program\n";
		}
		if(sel =="cd"||sel =="CD")
			break;
		if(sel == "calc")
			resu.calc();

		if(sel =="clear"||sel =="Clear"||sel =="CLEAR")
			resu.clear();// cout << string(50,'\n');
	}
}
//============================================================================================
void chem::presure()
{
	double k, c, f, an, atm, torr;
	string sel, ans;
	while (true){
		cout << "\nViper_Chem_Pressure-Converter: ";
		cin >> sel;
		resu.IN_History(sel);
		resu.univSelec(sel,sel);


		if(sel == "sea")
		{
			cout << "    Is the fluid exposed in the air: ";
			ans = resu.VDO();

			if(ans == "yes"||ans == "Yes"||ans == "YES")
			{
				cout << "    Enter atmospheric temp in pascals: ";
				cin >> c;
			}
			cout << "    Enter debth of water:              ";
			k = resu.VDO();
			cout << "    Enter gravity acceleration:        ";
			f = resu.VDO();

			an = c + (k * f * 1000);
			atm = an / 101325;
			torr = atm * 760;
			cout << "the presure at " << k << " is " << an << endl
				<< " ____________________________________________________\n"
				<< "|  atm          " << atm << " atm"<< endl
				<< "|  torr         " << torr << " torr"<< endl
				<< "|  mmHg         " << torr << " mmHg" << endl; 
		}
		if(sel == "help"||sel == "Help"||sel == "HELP"||sel == "ls"||sel == "LS")
		{
			cout << "________________________________________________________\n"
				<< setw(15) << "sea" << setw(40) << "find and convert pressures at sea debths\n"
				<< setw(15) << "clear" << setw(40) << "Clear screen\n"
				<< setw(15) << "calc" << setw(40) << "simple calculater\n"
				<< setw(15) << "cd"<< setw(40) << "Exit program\n";
		}
		if(sel =="cd"||sel =="CD")
			break;
		if(sel == "calc")
			resu.calc();

		if(sel =="clear"||sel =="Clear"||sel =="CLEAR")
			resu.clear();// cout << string(50,'\n');
	}
}
//===================================================================================
double chem::do_MOL_mas(string raw)
{
	string f ="*******",
	       split;
	char *mult;
	double cash =0, tx =0, stow,
	       Complex =0, numComplex =0;
	int index =0;

	///////////////////////////////////////////////////////////////////
	if(raw.find('(') >=0 && raw.find('(') <= raw.size()){
		split = splitForm(raw, numComplex);
		Complex = do_MOL_mas(split);
		Complex *= numComplex;

		int loc1 = raw.find('('),
		    loc2 = raw.find(')');
		if(loc2 >= 0&& loc2 <= raw.size())
			raw.erase(loc1, loc2);
	}
	///////////////////////////////////////////////////////////////////

	f = raw;
	//*/
	mult = new char[ raw.size() ];
	// fills string with *
	for(int i=0; i<raw.size(); i++)
	{
		f[i] = '*';
		mult[i] = ' ';
	}

	// brakes down formula
	for(int i=0; i<raw.size(); i++)
	{
		for(i; i<raw.size(); i++)
		{
			mult[i] = raw[i];
			f[i] = raw[i];

			if(raw[i] >='0'&&raw[i] <='9')
			{
				f[i] = '*';
			}
			if(raw[i+1] >='A'&&raw[i+1] <='Z'||raw[i+1] =='\0')
			{
				// Element isolater
				for(int v=0; v<raw.size(); v++)
				{
					if(f[index] != '*')
						index ++;
					else
						f.erase(index,1);
				}

				index = 0; // Resets index for next elemtnt


				for(int d=0; d< raw.size(); d++)
				{
					if(mult[d] >='0'&&mult[d] <='9')
						d++;
					else
						mult[d] = ' ';
				}

				stow = check(f); // checks element to pt

				tx = strtod(mult, NULL); 
				if(tx == 0)
					tx = 1;

				cash += stow * tx;


				f = raw;	
				for(int i=0; i<raw.size(); i++)
					f[i] = '*';
				for(int i=0; i<raw.size(); i++)
					mult[i] = ' ';

				break;
			}
		}
	}
	delete [] mult;
	return cash + Complex;
}
// ////////////////////////////////////////////////////////////////////////////////////////////////
// counts the number of elements in formula
double chem::do_ELE_count(string raw)
{
	string f ="*******",
	       split;
	char *mult;
	double cash =0, tx =0, stow,
	       numComplex, Complex =0;
	int index =0;

	f = raw;

	if(raw.find('(') >=0 && raw.find('(') <= raw.size()){
		split = splitForm(raw, numComplex);
		Complex = do_ELE_count(split);
		Complex *= numComplex;

		int loc1 = raw.find('('),
		    loc2 = raw.find(')');
		if(loc2 == 0)
			raw.erase(loc1, loc2);
	}

	f = raw;

	///////////
	mult = new char[ raw.size() ];
	// fills string with *
	for(int i=0; i<raw.size(); i++)
	{
		f[i] = '*';
		mult[i] = ' ';
	}

	// brakes down formula
	for(int i=0; i<raw.size(); i++)
	{
		for(i; i<raw.size(); i++)
		{
			mult[i] = raw[i];
			f[i] = raw[i];

			if(raw[i] >='0'&&raw[i] <='9')
			{
				f[i] = '*';
			}
			if(raw[i+1] >='A'&&raw[i+1] <='Z'||raw[i+1] =='\0')
			{
				// Element isolater
				for(int v=0; v<raw.size(); v++)
				{
					if(f[index] != '*')
						index ++;
					else
						f.erase(index,1);
				}

				index = 0; // Resets index for next elemtnt


				for(int d=0; d< raw.size(); d++)
				{
					if(mult[d] >='0'&&mult[d] <='9')
						d++;
					else
						mult[d] = ' ';
				}

				stow = 1; // insted of geting elements mass use 1 to count element symbol

				tx = strtod(mult, NULL); // tx is now used to count group of symbols ex 'O3' tx = 3
				if(tx == 0)
					tx = 1;

				cash += stow * tx; // Count all elements


				f = raw;	
				for(int i=0; i<raw.size(); i++)
					f[i] = '*';
				for(int i=0; i<raw.size(); i++)
					mult[i] = ' ';

				break;
			}
		}
	}
	delete [] mult;
	return cash;
}
//==============================================================================
double chem::do_SYM_count(string raw)// count the numer of symbols in formula
{
	string f ="*******";
	char *mult;
	double cash =0, tx =0, stow;
	int index =0;

	f = raw;

	mult = new char[ raw.size() ];
	// fills string with *
	for(int i=0; i<raw.size(); i++)
	{
		f[i] = '*';
		mult[i] = ' ';
	}

	// brakes down formula
	for(int i=0; i<raw.size(); i++)
	{
		for(i; i<raw.size(); i++)
		{
			mult[i] = raw[i];
			f[i] = raw[i];

			if(raw[i] >='0'&&raw[i] <='9')
			{
				f[i] = '*';
			}
			if(raw[i+1] >='A'&&raw[i+1] <='Z'||raw[i+1] =='\0')
			{
				// Element isolater
				for(int v=0; v<raw.size(); v++)
				{
					if(f[index] != '*')
						index ++;
					else
						f.erase(index,1);
				}

				index = 0; // Resets index for next elemtnt


				for(int d=0; d< raw.size(); d++)
				{
					if(mult[d] >='0'&&mult[d] <='9')
						d++;
					else
						mult[d] = ' ';
				}

				stow = 1; // insted of geting elements mass use 1 to count element symbol

				//tx = strtod(mult, NULL); // tx is now used to count group of symbols ex 'O3' tx = 3
				//if(tx == 0)
				//	tx = 1;

				cash += stow; //* tx; // Count all elements


				f = raw;	
				for(int i=0; i<raw.size(); i++)
					f[i] = '*';
				for(int i=0; i<raw.size(); i++)
					mult[i] = ' ';

				break;
			}
		}
	}
	delete [] mult;
	return cash;
}
//==============================================================================
string *chem::do_BREAK_formula(string raw, int hyperion)
{
	string f ="*******", tempCpy;
	char *mult;
	string *element;
	double cash =0, tx =0, stow;
	int index =0, K=0;

	element = new string[hyperion];

	f = raw;

	// fills string with *
	for(int i=0; i<raw.size(); i++)
		f[i] = '*';

	// brakes down formula
	for(int i=0; i<raw.size(); i++)
	{
		mult = new char[ raw.size() ];
		for(i; i<raw.size(); i++)
		{
			mult[i] = raw[i];
			f[i] = raw[i];

			if(raw[i] >='0'&&raw[i] <='9')
			{
				f[i] = '*';
			}
			if((raw[i+1] >='A'&&raw[i+1] <='Z')||raw[i+1] =='\0')
			{
				// Element isolater
				for(int v=0; v<raw.size(); v++)
				{
					if(f[index] != '*')
						index ++;
					else
						f.erase(index,1);
				}
				//////////////////////////////////////////////////////////
				// save element symbol into element array
				tempCpy = f;

				// if a complex is entered get rid of parenthesies
				for(int h=0; h< tempCpy.size(); h++)
					if((tempCpy[h] <'A' or tempCpy[h] >'Z') &&
							(tempCpy[h] <'a' or tempCpy[h] >'z'))
						tempCpy.erase(h,1);

				element[K] = tempCpy;

				K++;
				/////////////////////////////////////////////////////////

				index = 0; // Resets index for next elemtnt

				f = raw;	
				for(int w=0; w<raw.size(); w++)
				{
					f[w] = '*';
					mult[w] = 0;
				}
				break;
			}
		}
	}
	delete [] mult;
	return element;
}
//====================================================================================
// get individual weight of elements groups in the formula
double *chem::do_ELE_weigh(string raw)
{
	string f ="*******",
	       split;
	bool hasComplex = false;
	char *mult;
	double *cash, *temp1, *temp2;
	double tx =0, stow, numComplex;
	int index =0, arrControl=0,
	    fSize, splitSize;


	//////////////////////////
	if(raw.find('(') >=0 && raw.find('(') <= raw.size()){
		hasComplex = true;
		split = splitForm(raw, numComplex);
		splitSize = int(do_SYM_count(split));

		// call self to get the weight for the complex
		temp1 = do_ELE_weigh(split);

		// multiplys the weight of the element groups
		// by the number of these molocules that makes
		// up the complex
		for(int i=0; i< splitSize; i++)
			temp1[i] *= numComplex;

		int loc1 = raw.find('('),
		    loc2 = raw.find(')');
		if(loc2 >= 0&& loc2 <= raw.size())
			raw.erase(loc1, loc2);
	}
	///////////////////////////

	// get number of symbols in formula
	fSize = do_SYM_count(raw);

	// make an array to hold each symbols weight
	cash = new double[fSize];

	f = raw;

	// fills string with *
	for(int i=0; i<raw.size(); i++)
		f[i] = '*';

	// brakes down formula
	for(int i=0; i<raw.size(); i++)
	{
		mult = new char[ raw.size() ];
		for(i; i<raw.size(); i++)
		{
			// saves an array of characters so it could be
			// used to get a numaric value
			mult[i] = raw[i];
			f[i] = raw[i];

			// replace numbers in f (coppy) string with *
			// so that it will not be included in final string
			if(raw[i] >='1'&&raw[i] <='9')
				f[i] = '*';

			// finds elements by looking for capital leters
			if(raw[i+1] >='A'&&raw[i+1] <='Z'||raw[i+1] =='\0')
			{
				// Element isolater
				for(int v=0; v<raw.size(); v++)
				{
					// if computer does not find a * add 1 to index
					if(f[index] != '*')
						index ++;
					else
						// if computer finds a * then remove it
						f.erase(index,1);
				}

				index = 0; // Resets index for next elemtnt


				for(int d=0; d< raw.size(); d++)
				{
					if(mult[d] >='0'&&mult[d] <='9')
						d++;
					else
						// erase evrything within mult array thats
						// not a number
						mult[d] = ' ';
				}

				stow = check(f); // checks if element is a element
				// and get atomic weight

				tx = strtod(mult, NULL);// interprats numbers from string
				if(tx == 0)
					tx = 1;

				cash[arrControl] = stow * tx; // calculate number of elremnts
				// and stor them properly into an
				// cash arr
				//
				arrControl++; // increment cash array index

				f = raw;	
				for(int w=0; w<raw.size(); w++)
				{
					f[w] = '*';
					mult[w] = 0;
				}
				break;
			}
		}
	}
	if(hasComplex == true)
	{
		temp2 = new double[fSize];
		for(int i=0; i<fSize; i++)
			temp2[i] = cash[i];

		delete [] cash;
		cash = new double[fSize + splitSize + 1];

		for(int i=0; i< (fSize + splitSize); i++){
			if(i < fSize)
				cash[i] =  temp2[i];
			else
				cash[i] =  temp1[i-fSize];
		}

		delete [] temp2;
		delete [] temp1;
	}
	delete [] mult;
	return cash;
}
////////////////////////////////////////////////////////////////////
bool chem::soluble(string raw, int &cation)
{
	string cpyOfRaw = raw,
	       split;
	string *ele;
	int eleArrSize, locat1, locat2;
	double numComplex;

	eleArrSize = do_SYM_count(raw);
	ele = new string[eleArrSize];

	ele = do_BREAK_formula(raw, raw.size());
	///////////////////////////////////////////////////
	if(raw.find('(') >=0 && raw.find('(') <= raw.size()){
		split = splitForm(raw, numComplex);
		cation = numComplex;
	}
	///////////////////////////////////////////////////

	// alkali salts
	for(int i=0; i< raw.size(); i++)
		for(int u=0; u<6; u++)
			if(ele[i] == ions[u].ionName){
				locat1 = raw.find(ele[i]);
				locat2 = locat1 + 3;

				cpyOfRaw.erase(locat1,locat2);
				cation = strtod(cpyOfRaw.data(), NULL);
				return true;
			}
	// salts of ClO4 and ClO3
	for(int i=0; i< raw.size(); i++){
		if(raw.find("ClO4") <= raw.size() && raw.find("ClO4") >= 0){
			cation = 1 * cation;
			return true;
		}
		else if(raw.find("ClO3") <= raw.size() && raw.find("ClO3") >= 0){
			cation =1 * cation;
			return true;
		}
	}
	// salts of acitate
	if(raw.find("C2H3O2") <= raw.size() && raw.find("C2H3O2") >= 0){
		cation =1 * cation;
		return true;
	}

	// salts of halides
	if((raw.find("Ag") <0 or raw.find("Ag") > raw.size()) || 
			(raw.find("Hg2") <0 or raw.find("Hg2") > raw.size()) || 
			(raw.find("Pb") <0 or raw.find("Pb") > raw.size()) || 
			(raw.find("HgBr2") <0 or raw.find("HgBr2") > raw.size()) || 
			(raw.find("HgI2") <0 or raw.find("HgI2") > raw.size()))
	{
		for(int i=0; i< raw.size(); i++)
			for(int u=43; u<48; u++){
				if(ele[i] == ions[u].ionName){
					locat1 = raw.find(ele[i]);
					locat2 = locat1 + 3;

					cpyOfRaw.erase(locat1,locat2);
					cation = strtod(cpyOfRaw.data(), NULL);
					return true;
				}
			}
	}

	// salts of SO4
	if(raw.find("SO4") <= raw.size() && raw.find("SO4") >= 0){
		if((raw.find("Ba") <0 or raw.find("Ba") > raw.size()) || 
				(raw.find("Ca") <0 or raw.find("Ca") > raw.size()) || 
				(raw.find("Pb") <0 or raw.find("Pb") > raw.size()) || 
				(raw.find("Ag") <0 or raw.find("Ag") > raw.size()))
			return true;
	}
	if((raw.find("NO") >=0 and raw.find("NO") <= raw.size()) &&
			(raw.find("Ag") < 0 and raw.find("Ag") > raw.size()))
		return true;

	delete [] ele;
	return false;
}
////////////////////////////////////////////////////////////////////
string chem::splitForm(string in, double &mult)
{
	char *inParen;
	char multArr[2];
	int count=0;
	string split;

	inParen = new char[in.size()+5];

	// count the open perenthasies
	for(int i=0; i <in.size(); i++)
		if(in[i] == '(')
			count++;

	// isolate the formula within the perenthesies
	for(int i=0; i <in.size(); i++)
	{
		if(in[i] == '(')
			for(int u=0; u <in.size(); u++)
			{
				if(in[u+i+1] == ')')
					count--;
				if(inParen[u] != in[u+i+1])
					inParen[u] = '\0';
				if(count ==0)
					break;
				else
					inParen[u] = in[u+i+1];
			}
		if(count == 0)
			break;
	}

	// get the number of the complex molocules
	if(in[in.find(')')+1] >='0' and in[in.find(')')+1] <='9'){
		multArr[0] = in[in.find(')') + 1];
		if(in[in.find(')')+2] >= '0' and in[in.find(')')+2] <='9')
			multArr[1] = in[in.find(')') +2];
	}

	// defalt if there are no numbers one is passed
	if(multArr[0] == '\0')
		multArr[0] ='1';
	// convert multArr from a string to a number
	mult = strtod(multArr, NULL);

	split.assign(inParen);

	delete [] inParen;
	return split;
}

//----------------------------------------------------------------------
double chem::check(string c)// checks puriotic table and retrives atomic weight
{
	double out =1; 

	for(int i=0; i <118; i++)
		if(c == pt[i].name)
			out = pt[i].w;

	return out;
}
//
//
////////////////////////////////////////////////////////////////////////////////
//
//
void chem::convert(string sel, string lab)
{
	while (true){
		cout << "\nViper_Chem_MesurCnverter: ";
		cin >> sel;
		resu.IN_History(sel);
		resu.univSelec(sel,sel);


		if(sel == "temp")
			temp();
		if(sel == "metft")
			meters();
		if(sel == "klml")   
			milklm();
		if(sel == "energy")   
			energy();
		if(sel == "pressure")   
			presure();
		if(sel == "help" || sel == "ls")
		{
			cout << "________________________________________________________\n" 
				<< setw(15) << "energy" << setw(40) << "Convert calories to joules\n"
				<< setw(15) << "temp"<< setw(40) << "Convert Fahrenheit to C and K\n"
				<< setw(15) << "metft" << setw(40) << "Convert meter to f\n"
				<< setw(15) << "klml" << setw(40) << "Convert Kilometers to Miles\n"
				<< setw(15) << "pressure" << setw(40) << "Calculate and convert pressure\n"
				<< setw(15) << "calc" << setw(40) << "simple calculater\n"
				<< setw(15) << "clear" << setw(40) << "Clear screen\n"
				<< setw(15) << "cd"<< setw(40) << "Exit program\n";
		}
		if(sel =="cd"||sel =="CD")
			break;
		if(sel == "calc")
			resu.calc();

		if(sel =="clear")
			resu.clear();
	}
}
//============================================================================================
void chem::oxidationState()
{
	char arr[2];
	bool gotoAns=false, knownI = true, 
	     brakeIonEcluder = false;
	int Charge =0, tab =0, count=0, lim,
	    propex=0, exclude, ChargeTEMP;
	string *elName;
	string sel, formla, coppy, elNameCash;

	struct elprop
	{
		string ionN;
		double oxyion;
		int prop;
		double multiply;
	}ep[50];

	while(true)
	{
		cout << "\nViper_Chem_OxidationState: ";
		cin >> sel;
		resu.IN_History(sel);
		resu.univSelec(sel,sel);

		coppy = formla;
		if(sel == "findox")
		{
			cout << "\n    Enter the molecular formula of the compound: ";
			cin >> formla;
			cout << endl;

			elName = do_BREAK_formula(formla, formla.size()); // brakes formula into individual symbols
			lim = do_SYM_count(formla); // counts elemen symbols ex O3 =1, H2 =1, CuSO4 =3

			coppy = formla;
			for(int i=0; i< lim; i++)
			{// get number of preticular elemtnts and use this as an multiplyer
				elNameCash = elName[i];
				coppy.erase(0, elNameCash.size());

				if(coppy[0] >= '0' && coppy[0] <='9')
				{
					arr[0] = coppy[0];
					coppy.erase(0,1);

					if(coppy[0] >= '0' && coppy[0] <='9')
					{
						arr[1] = coppy[0];
						coppy.erase(0,1);
					}
				}
				ep[i].multiply = strtod(arr, NULL);

				if(ep[i].multiply == 0)
					ep[i].multiply = 1;
				arr[0]= '\0';
				arr[1]= '\0';
			}
			//structure inicalizer
			for(int i=0; i< lim; i++)
			{
				ep[i].ionN = elName[i];
			}
			// checks for pure elemens if compound is a pure element then assign it 0
			if(lim > 1)
			{
				gotoAns = false;
			}
			else
			{
				ep[tab].oxyion = 0;
				Charge = 0;
				ep[tab].ionN = elName[0];
				gotoAns = true;
			}
			//======================================================================================
			if(gotoAns == false)
			{
				for(int i=0; i<formla.size(); i++) // find alcoli and some metal ions
				{
					while( tab< lim)
					{
						//monovalent metal cations will have an oxidation state equal to their normal charges
						for(int u=0; u<20; u++)
						{
							if(ep[i].ionN == ions[u].ionName)
							{
								ep[tab].oxyion = ions[u].ionCharge *ep[i].multiply;
								Charge += ions[u].ionCharge * ep[i].multiply;
								ep[tab].prop = 3;
								tab++;
								knownI = false;
							}
						}
						if(knownI == false)
							break;

						//in its compounds the oxidation state of hydrogen is +1 florien is -1 ///////////
						if(ep[i].ionN == "H"|| ep[i].ionN == "F") // find H+ and F- ions
						{
							if(ep[i].ionN == "H")
								ep[tab].oxyion = (1 * ep[i].multiply);
							else
								ep[tab].oxyion = (-1 * ep[i].multiply);
							Charge += ep[i].oxyion;
							ep[tab].prop = 4;
							tab++;
							knownI = false;
						}
						if(knownI == false)
							break;

						//in its compounds Oxygen has an oxidation state of -2 ///////////////////////////
						if(ep[i].ionN == "O")
						{
							ep[tab].oxyion = (ions[49].ionCharge * ep[i].multiply);
							Charge += (ions[49].ionCharge * ep[i].multiply);
							ep[tab].prop = 5;
							tab++;
							knownI = false;
						}
						if(knownI == false)
							break;

						// in their biary compounds with metals the ellements of group 7A to 5A have -1,-2,-3
						for(int u=42; u<61; u++) // find ions from group 7A to 5A
						{
							if(ep[i].ionN == ions[u].ionName)
							{
								ep[tab].oxyion = ions[u].ionCharge *ep[i].multiply;
								Charge += ions[u].ionCharge * ep[i].multiply;
								ep[tab].prop = 6;
								tab++;
								knownI = false;
							}	
						}
						if(knownI == false)
							break;

						ep[tab].ionN = "*";
						ep[tab].oxyion =0;
						knownI = true;
						tab++;
						break;
					}
					knownI = true;
				}
				/////////////////////////////////////////////////////////////////////////////////////
				// if program encounters an element with unknown charge 
			}
			count = 0;
			for(int i=0; i<lim; i++)
			{// Charg assighnment on unknown ions
				ChargeTEMP = Charge;
				if(ep[i].ionN == "*")
				{
					count++;
					if(count > lim)
					{// if all elements have an unknown ionic charge (ALOIS) assign evrythig to 0
						for(int x=0; x<lim; x++)
						{
							ep[x].oxyion =0;
							ep[x].ionN = elName[x];
						}
						brakeIonEcluder = false;
						break;
					}
					//reassines elements name
					ep[i].ionN = elName[i];
					if(Charge > 0)
						ep[i].oxyion = ((ChargeTEMP *1.0) / ep[i].multiply);
					else
						ep[i].oxyion = ((-1.0 * ChargeTEMP) / ep[i].multiply);
					Charge += ep[i].oxyion * ep[i].multiply;
					brakeIonEcluder = true;
				}
				else
					brakeIonEcluder = false;
			}
			//-------------------------------------------------------------------------------------------------
			// if all elements are known charges then look at rule prioraties and exclude highest number rule
			// AKA ION EXCLUDER 
			//	for(int u=0; u<lim; u++)
			//	{
			/// CHECKS if formula is a known polyatomic ion
			brakeIonEcluder = knownIonExcluder(formla);
			//	}
			//======================================================
			propex =0;		
			if(brakeIonEcluder == true)
			{
				if(Charge > 0|| Charge <0)  
				{
					for(int i=0; i< lim; i++)
					{
						if(ep[i].prop > propex)
						{
							// find the highest property
							propex = ep[i].prop;
							exclude = i;
						}
					}
					// apply the exclusion and correct the charg imbalance
					if(Charge > 0)
					{
						// correct charge imbalance if charg is grater than 0
						Charge = (Charge - ep[exclude].oxyion);
						ep[exclude].oxyion = (Charge * -1.0) / ep[exclude].multiply;
					}
					else
					{
						// correct charge imbalance if charg is less than 0
						Charge = Charge + abs(ep[exclude].oxyion);
						ep[exclude].oxyion = (-1.0 * Charge) / ep[exclude].multiply;
					}
				}
			}
			// get charg for individual atoms //////////////////////////////////
			//DISPLAY RESUSLT ////
			cout << "\n_____________________________________________________\n"<<
				"   element   |    charge |  charge shared by # atoms\n" <<
				"-----------------------------------------------------\n";
			for(int i=0; i<lim; i++)
				cout << setw(13) << ep[i].ionN << setw(11) << ep[i].oxyion << setw(17) << ep[i].multiply << endl;

			tab =0;
			Charge =0;
			count =0;
			delete [] elName;
		}
		if(sel == "help"|| sel == "ls")
		{
			cout << "________________________________________________________\n" << 
				setw(15) << "findox" << setw(40) << "find oxidation state of componets\n"<< 
				setw(15) << "calc" << setw(40) << "simple calculater\n"<< 
				setw(15) << "clear" << setw(40) << "Clear screen\n"<< 
				setw(15) << "cd"<< setw(40) << "Exit program\n";
		}
		if(sel == "calc")
			resu.calc();
		if(sel == "cd")
			break;
		if(sel == "clear")
			resu.clear();
	}
}
//=============================================================================================
bool chem::knownIonExcluder(string in)
{
	bool notIon =true;
	for(int i=0; i< 55; i++)
	{
		if(in == knownIon[i])
		{
			return false;
			break;
		}
	}

	return notIon;
}
//===============================================================================================
void chem::solutions()
{
	double molAcid, molBase, baseVol,
	       solutionVol, Mbase, Macid,
	       ans, HA, A, H, ph,
	       solute, torr, temp, atm;
	formula solMol1, solMol2;
	string sel, cpySolution;
	string *elArr;

	while (true){
		cout << "\nViper_Chem_Solutions: ";
		cin >> sel;
		resu.IN_History(sel);
		resu.univSelec(sel,sel);

		if(sel == "ka")
		{
			cout << "    Enter the mols of acid used: ";
			molAcid = resu.VDO();
			cout << "    Enter the VOLUME of acidic solution: ";
			solutionVol = resu.VDO();
			cout << "    Enter the Molarity of base used: ";
			molBase = resu.VDO();
			cout << "    Enter the VOLUME of base used: ";
			baseVol = resu.VDO();
			cout << "    Enter the final PH of the solution: ";
			cin >> ph;

			ph = pow(10, (-1 * ph));
			Mbase = baseVol * molBase; 
			Macid = molAcid - Mbase;
			Mbase = Mbase - Macid;

			HA = Macid / (solutionVol + baseVol);
			A = Macid / (solutionVol + baseVol);
			H = HA;

			ans = (ph* (A + ph))/ (HA - ph);
			cout << "\nThe Ka is " << ans << endl;
		}
		if(sel == "osmas")
		{
			cout << "    Enter the grames of the solute: ";
			solute = resu.VDO();
			cout << "    Enter the volume of solution: ";
			solutionVol = resu.VDO();
			cout << "    Enter the presure found in atmt: ";
			atm = resu.VDO();
			cout << "    Enter the temperatur in kelvin: ";
			temp = resu.VDO();

			ans = atm / (0.082057 * temp);
			ans = (1 / ans);
			cout << "\nThe molar mass of the compound is: " << ans << endl;
		}
		if(sel == "ospres")
		{
			cout << "    Enter the temprature in kelvin: ";
			temp = resu.VDO();
			cout << "    Enter the Molarity: ";
			H = resu.VDO();

			ans = H * 0.082057 * temp;
			cout << "\nThe Osmotic Pressure is " << ans << " atm"<< endl;
		}
		if(sel == "ostemp")
		{
			cout << "    Enter the osmotic presure in atm: ";
			atm = resu.VDO();
			cout << "    Enter the Molarity: ";
			H = resu.VDO();

			ans = atm / (H * 0.082057);
			cout << "\nThe temprature is " << ans << " k"<< endl;
		}
		if(sel == "osmol")
		{
			cout << "    Enter the osmotic presure in atm: ";
			atm = resu.VDO();
			cout << "    Enter the temprature: ";
			temp = resu.VDO();

			ans = atm / (temp * 0.082057);
			cout << "\nThe molarity is " << ans << " k"<< endl;
		}
		if(sel == "vappres")
		{
			cout << "\n    Enter the Molecular Formula of the solute:   ";
			cin >> solMol1;
			cout << "    Enter grames of " << solMol1 << " desolved: ";
			solute = resu.VDO();
			cout << "    Enrer the Molecular Formula of the solution: ";
			cin >> solMol2;
			cout << "    Enter grames of " << solMol2 << " used: ";
			A = resu.VDO();
			cout << "    Origanal vapor presure of the fluid: ";
			H = resu.VDO();

			solute = solute * (1 / solMol1.mol());
			A = A * (1 / solMol2.mol());
			HA = A / (A + solute);
			torr = HA * H;

			cout << "\nThe vapor presure of the solution is: " << torr << endl;
		}
		if(sel == "vapion")
		{
			cout << "\n    Enter the Molecular Formula of the solute:   ";
			cin >> solMol1;
			cout << "    Enter grames of " << solMol1 << " desolved: ";
			solute = resu.VDO();

			//cpySolution = solMol1.str();
			elArr = do_BREAK_formula(solMol1.str(), solMol1.size());

			delete [] elArr;
		}
		if(sel == "help"|| sel == "ls")
		{
			cout << "________________________________________________________\n" << 
				setw(15) << "ka" << setw(40) << "find oxidation state of componets\n"<< 
				setw(15)<<"osmas"<<setw(40)<<"find molar mass using osmotic pressure\n"<< 
				setw(15)<<"osmol"<<setw(40) << "find molarity using osmotic pressure\n"<< 
				setw(15) << "ospres" << setw(40) << "find osmotic presure\n"<< 
				setw(15)<<"ostemp"<<setw(40) <<"find the temprature of osmotic Expmt\n"<< 
				setw(15) << "vappres" << setw(40) << "find vapor presure of solution\n"<< 
				setw(15) << "calc" << setw(40) << "simple calculater\n"<< 
				setw(15) << "clear" << setw(40) << "Clear screen\n"<< 
				setw(15) << "cd"<< setw(40) << "Exit program\n";
		}
		if(sel == "calc")
			resu.calc();
		if(sel == "cd")
			break;
		if(sel == "clear")
			resu.clear();
	}
}
void chem::balance(){
	bool excape = false;
	char *tstr;
	int index, rcharg, pcharg, point,sycnt,
	    bl, numAtomR=0, numAtomP=0,pos=0;
	double chargA, chargB, noDoubles;
	double *feed;
	formula tmp, tmp2;
	string sel, unbal,cp, cp2="", cp3;
	string *tar;

	vipLl <compound>reac;
	vipLl <compound>prod;
	compound tc;
	matrix A,B;


	while (true){
		cout << "\nViper_Chem_Balanced-equations: ";
		cin >> sel;
		resu.IN_History(sel);
		resu.univSelec(sel,sel);

		if(sel == "ubrp"){
			cout << "    Enter the molecular equation:\n     >>> ";
			getline(cin, unbal);

			// ensure the user will get the entier line
			if(unbal[0] == '\n'or unbal.size() <2){
				unbal.erase();
				getline(cin, unbal);
			}

			resu.setNoSpace(unbal, unbal);
			// get reactance ===================================================
			for(int i=0; i< unbal.size(); i++){
				if(unbal[i]!='+'and unbal[i]!='='and unbal[i] !=' '){
					cp.push_back( unbal[i]);
					if(unbal[i+1] == '\0')
						goto pushEndCompound;
				}else{
pushEndCompound:
					tmp = cp;
					//////////////////////////////////////////////////
					if(cp != ""){
						// prepare compound
						tmp = cp;
						tc.name = cp;
						tmp = cp;
						tc.elm = tmp.chop();
						// push compound onto list
						reac.push(tc);
					}
					////////////////////////////////////////////////////
					cp="";
					if(unbal[i] == '=')
						break;
				}
			}
			point = unbal.find('=');
			point = ((point <0 or point >=unbal.size())?unbal.size(): point);
			// get products =================================================
			for(int i=point; i< unbal.size(); i++){
				if(unbal[i] == '=')
					continue;
				if(unbal[i]!='+' and unbal[i] != ' '){
					cp.push_back( unbal[i]); 
					if(unbal[i+1]=='\0')
						goto pushEndProductCompound;
				}else{
pushEndProductCompound:
					tmp = cp;
					if(cp != ""){
						// prepare compound
						tmp = cp;
						tc.name = cp;
						tmp = cp;
						tc.elm = tmp.chop();
						// push compound onto list
						prod.push(tc);
					}
					cp="";
				}
			}
			//==================================================================
			sycnt = 0;
			// count the numver of symbols in reactence side
			for(int i=0; i<reac.size(); i++){
				tmp = reac[i].name;
				sycnt += tmp.size();
			}
			// make an empty string array to hold symbols
			tar = new string[sycnt];
			for(int z=0; z<sycnt; z++)
				tar[z] = " ";

			bl =0;
			// fill string aray
			for(int i=0; i<reac.size(); i++){
				tmp = reac[i].name;
				for(int x=0; x<tmp.size(); x++){
					for(int z=0; z<bl; z++){
						if(tar[z] == tmp[x]){
							excape = true;
							break;
						}else
							excape = false;
					}
					if(excape == false or bl==0)
						tar[bl++] = tmp[x];
				}
			}

			feed = new double[(reac.size()+prod.size())*bl];
			excape = true;
			// create the input array for the matrix
			for(int b=0,q=0; b<bl; b++){
				// reactance
				for(int i=0,x=0; i<reac.size(); i++){
					tmp = reac[i].name;
					for(x=0; x<tmp.size(); x++)
						if(tmp[x] == tar[b]){
							excape = true;
							break;
						}
						else
							excape = false;
					if(excape == true){
						tmp2 =  reac[i].elm[x];
						feed[q++] = tmp2.count();
					}else{
						feed[q++] = 0;
					}
				}

				// products 
				for(int i=0,x=0; i<prod.size(); i++){
					tmp = prod[i].name;
					for(x=0; x<tmp.size(); x++)
						if(tmp[x] == tar[b]){
							excape = true;
							break;
						}
						else
							excape = false;
					if(excape == true){
						tmp2 = prod[i].elm[x];
						feed[q++] = -1 * tmp2.count();
					}else{
						feed[q++] = 0;
					}
				}
			}

			// balance equation
			A.build((reac.size()+prod.size()), ((reac.size()+prod.size())*bl), feed);
			B = A.null();

			// Convert fractinal equations to intger equations
			for(int e=0; e<B.getRow() ; e++){
				for(int i=0; i<B.getRow(); i++)
					if(B.get(i,0)>0 and B.get(i,0)<1){
						excape = true;
						index= i;
						break;
					}else
						excape = false;
				if(excape == true)
					B = B * resu.redFrac( resu.round(B.get(index,0)));
			}

			// print balanced equation
			cout << "\n      \\ ";
			for(int r=0;r<reac.size(); r++){
				cout << B.get(pos++,0) << reac[r].name << ((r <reac.size()-1)?" + ":"");
			}
			cout << " = ";
			for(int p=0;p<prod.size(); p++){
				cout << B.get(pos++,0) << prod[p].name << ((p <prod.size()-1)?" + ":"");
			}
			cout << "\n       \\_______________________________________\n";


			bl =pos =0;
			delete [] feed;
			delete [] tar;
			unbal.erase();
			reac.erase();
			prod.erase();
		}
		if(sel == "help" or sel == "ls"){
			cout << "________________________________________________________\n"
				<< setw(15) << "ubrp" << setw(40) << "Balance reactance and products\n"
				<< setw(15) << "calc" << setw(40) << "Simple calculater\n"
				<< setw(15) << "clear" << setw(40) << "Clear screen\n"
				<< setw(15) << "cd" << setw(40) << "Exit program\n";
		}
		if(sel == "calc")
			resu.calc();
		if(sel == "cd")
			break;
		if(sel == "clear")
			resu.clear();
	}
}
void chem::hgl(){
	string sel;
	double kh, p, x, c;
	while(true){
		cout << "\nViper_Chem_Henry-Gas-Law: ";
		cin >> sel;
		resu.IN_History(sel);
		resu.univSelec(sel,sel);

		if(sel == "hgcatm"){
			cout << "    Enter presure of the system: ";
			p = resu.VDO();
			cout << "    Enter mole faction of the gas: ";
			x = resu.VDO();

			p = atmPas(p);

			cout << "\nHenry constant is: "<< p/x << " (pc/mol)\n";
		}
		if(sel == "molatm"){
			cout << "    Enter presure of the system: ";
			p = resu.VDO();
			cout << "    Enter Henry constant: ";
			kh = resu.VDO();

			p = atmPas(p);

			cout << "\nMoles deslolved: "<< p/kh << endl;
		}
		if(sel == "atm"){
			cout << "    Enter moles desolved in solution: ";
			x = resu.VDO();
			cout << "    Enter Henry constant: ";
			kh = resu.VDO();

			cout << "\nPresure requiered to delolve "<< x << " moles of gas: "<< pasAtm(x*kh) << " (atm)\n";
		}
		if(sel == "hgcpasc"){
			cout << "    Enter presure of the system: ";
			p = resu.VDO();
			cout << "    Enter mole faction of the gas: ";
			x = resu.VDO();

			cout << "\nHenry constant is: "<< p/x << " (pc/mol)\n";
		}
		if(sel == "molpasc"){
			cout << "    Enter presure of the system: ";
			p = resu.VDO();
			cout << "    Enter Henry constant: ";
			kh = resu.VDO();

			cout << "\nMoles deslolved: "<< p/kh << endl;
		}
		if(sel == "pasc"){
			cout << "    Enter moles desolved in solution: ";
			x = resu.VDO();
			cout << "    Enter Henry constant: ";
			kh = resu.VDO();

			cout << "\nPresure requiered to delolve "<< x << " moles of gas: "<< (x*kh) << " (pa)m\n";
		}
		if(sel == "hgcpsi"){
			cout << "    Enter presure of the system: ";
			p = resu.VDO();
			cout << "    Enter mole faction of the gas: ";
			x = resu.VDO();

			p = psiPas(p);

			cout << "\nHenry constant is: "<< p/x << " (pc/mol)\n";
		}
		if(sel == "molpsi"){
			cout << "    Enter presure of the system: ";
			p = resu.VDO();
			cout << "    Enter Henry constant: ";
			kh = resu.VDO();

			p = psiPas(p);

			cout << "\nMoles deslolved: "<< p/kh << endl;
		}
		if(sel == "psi"){
			cout << "    Enter moles desolved in solution: ";
			x = resu.VDO();
			cout << "    Enter Henry constant: ";
			kh = resu.VDO();

			cout << "\nPresure requiered to delolve "<< x << " moles of gas: "<< pasPsi(x*kh) <<" (psi)m\n";
		}
		if(sel == "hgcbar"){
			cout << "    Enter presure of the system: ";
			p = resu.VDO();
			cout << "    Enter mole faction of the gas: ";
			x = resu.VDO();

			p = barPas(p);

			cout << "\nHenry constant is: "<< p/x << " (pc/mol)\n";
		}
		if(sel == "molbar"){
			cout << "    Enter presure of the system: ";
			p = resu.VDO();
			cout << "    Enter Henry constant: ";
			kh = resu.VDO();

			p = barPas(p);

			cout << "\nMoles deslolved: "<< p/kh << endl;
		}
		if(sel == "bar"){
			cout << "    Enter moles desolved in solution: ";
			x = resu.VDO();
			cout << "    Enter Henry constant: ";
			kh = resu.VDO();

			cout << "\nPresure requiered to delolve "<< x << " moles of gas: "<< pasBar(x*kh) <<" (psi)m\n";
		}
		if(sel == "help" or sel == "ls"){
			cout << "________________________________________________________\n"
				<< setw(15) << "ATM"     << setw(40) << "Find ATM needed to desolve gasses\n"
				<< setw(15) << "bar"     << setw(40) << "Find bar presure needed to desolve gas\n"
				<< setw(15) << "hgcATM"  << setw(40) << "Find henry constant using ATM\n"
				<< setw(15) << "hgcBar"  << setw(40) << "Find henry constant using bar\n"
				<< setw(15) << "hgcPasc" << setw(40) << "Find henry constant using pascal\n"
				<< setw(15) << "molATM"  << setw(40) << "Find mols desolved using ATM\n"
				<< setw(15) << "molpasc" << setw(40) << "Find mols desolved using pascal\n"
				<< setw(15) << "pasc"    << setw(40) << "Find pascal needed to desolve gas\n"
				<< setw(15) << "calc"    << setw(40) << "Simple calculater\n"
				<< setw(15) << "clear"   << setw(40) << "Clear screen\n"
				<< setw(15) << "cd"      << setw(40) << "Exit program\n";
		}
		if(sel == "calc")
			resu.calc();
		if(sel == "cd")
			break;
		if(sel == "clear")
			resu.clear();
	}
}
// (from) ==(change to)==> (this)
double chem::atmPas(double x){
	return (x * 101325);
}
double chem::atmBar(double x){
	return (x * 1.01325);
}
double chem::atmPsi(double x){
	return (x * 14.6959488);
}
double chem::pasAtm(double x){
	return (x * 9.86923267e-6);
}
double chem::pasBar(double x){
	return (x * 1.0e-5);
}
double chem::pasPsi(double x){
	return (x * .000145037738);
}
double chem::psiPas(double x){
	return (x * .000145037738);
}
double chem::psiAtm(double x){
	return (x * .0680459639);
}
double chem::psiBar(double x){
	return (x* .0689475729);
}
double chem::barPsi(double x){
	return (x * 14.5037738);
}
double chem::barAtm(double x){
	return (x * .986923267);
}
double chem::barPas(double x){
	return (x* 100000);
}
double chem::farCel(double x){
	return((x-32.)*5.)/9.;
}
double chem::farKel(double x){
	return( celKel( farCel(x) ));
}
double chem::celFar(double x){
	return (x*1.8)+32.;
}
double chem::celKel(double x){
	return (x+273.15);
}
double chem::celRac(double x){
	return (x +273.15)*(9./5.);
}
double chem::kelCel(double x){
	return (x - 273.15);
}
double chem::kelFar(double x){
	return (celFar( kelCel(x) ));
}
double chem::kelRac(double x){
	return (celRac( kelCel(x) ));
}
double chem::racFar(double x){
	return (x - 458.67);
}
double chem::racCel(double x){
	return (farCel( racFar(x) ));
}
double chem::racKel(double x){
	return (celKel( racCel(x) ));
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void chem::clear()
{
	system("clear");
	// cout << string(50,'\n');
}
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
void chem::help()
{
	cout << "________________________________________________________\n";
	cout << setw(15) << "autotitrator" << setw(40) << "titrates strong acids and bases\n"
		<< setw(15) << "bal" << setw(40) << "Balance chemical equations\n"
		<< setw(15) << "boyllaw" << setw(40) << "Find volumes/presure of an ideal gas\n"
		<< setw(15) << "charlaw" << setw(40) << "Find volumes of gases from temp\n"
		<< setw(15) << "convert" << setw(40) << "Conversion calculations\n"
		<< setw(15) << "elecplat" << setw(40) << "Find the time/amout for electroplating\n"
		<< setw(15) << "eqlib" << setw(40) << "Find chemical equilibrium\n"
		<< setw(15) << "frzpoint" << setw(40) << "Boling/freezin point evaluation\n"
		<< setw(15) << "henry" << setw(40) << "Henry gas law\n"
		<< setw(15) << "idelgas" << setw(40) << "Find the volum/mol of ideal gass\n"
		<< setw(15) << "oxystate" << setw(40) << "Find oxidation states of ions\n"
		<< setw(15) << "solutions" << setw(40) << "Properties of aqueous solutions\n"
		<< setw(15) << "stoich" << setw(40) << "Find mulecular fomula by precents\n"
		<< setw(15) << "ph" << setw(40) << "Find pH/[H]/[pOH]/pOH\n"

		<< setw(15) << "calc" << setw(40) << "Simple calculater\n"
		<< setw(15) << "coatl" << setw(40) << "search for program\n"
		<< setw(15) << "cd" << setw(40) << "return to phisics menue\n"
		<< setw(15) << "chmod" << setw(40) << "Change subject phisics/chem/trig\n"
		<< setw(15) << "clear" << setw(40) << "Clear screen\n"
		<< setw(15) << "history" << setw(40) << "show most keystrokes\n"
		<< setw(15) << "rec" << setw(40) << "record your notes and observations\n"
		<< setw(15) << "search" << setw(40) << "search for program\n"
		<< setw(15) << "exit"<< setw(40) << "Exit program\n";
}

// class destructor
chem::~chem()
{
	// insert your code here
}
